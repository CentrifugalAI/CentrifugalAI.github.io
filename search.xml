<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenMP 入门指南</title>
      <link href="/2022/08/31/OpenMP%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2022/08/31/OpenMP%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本文是参考人大编程集训随堂课件和 <a href="https://www.openmp.org/resources/refguides/">OpenMP 官方文档（点击跳转）</a> 总结的笔记，听课前晚为调一个 bug 两点多才睡，可能存在听课不仔细导致的一些疏漏和错误，欢迎指出，感谢！</p></blockquote><h1 id="vscode-设置-OpenMP-支持"><a href="#vscode-设置-OpenMP-支持" class="headerlink" title="vscode 设置 OpenMP 支持"></a><code>vscode</code> 设置 <code>OpenMP</code> 支持</h1><p>安装过 <code>GCC</code> 之后就可以直接进行 <code>OpenMP</code> 编程，但是需要指定一些编译选项——</p><p>如果是使用 <code>vscode</code> 进行操作，只需要对文件 <code>.vscode/tasks.json</code> 进行更改即可：</p><p>原本的 <code>&quot;args&quot;</code> 参数如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><strong>将 <code>&quot;-g&quot;,</code> 修改为 <code>&quot;-fopenmp&quot;,</code> 即可，注意逗号</strong>。</p><p>可以用下面这个简单的代码验证一下是否可以使用 <code>OpenMP</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;omp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _OPENMP</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以下假定代码文件名为 <code>try.cpp</code></p></blockquote><p>或在终端使用如下命令编译并运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g++ -fopenmp try.cpp -o try.exe</span><br><span class="line">&gt;&gt;&gt; ./try.exe</span><br></pre></td></tr></table></figure><p>也可以创建一个 <code>bash</code> 脚本，然后用比较简短的命令运行</p><p> <code>bash</code> 脚本名：<code>omp.sh</code>， 里面写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -fopenmp try.cpp -o try.exe</span><br><span class="line">./try.exe</span><br></pre></td></tr></table></figure><p>只需要以下命令一键运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bash opm.sh</span><br></pre></td></tr></table></figure><h1 id="OpenMP-简介入门"><a href="#OpenMP-简介入门" class="headerlink" title="OpenMP 简介入门"></a><code>OpenMP</code> 简介入门</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。</p></li><li><p>线程：是进程的一个执行单元，是进程内的调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</p></li></ul><blockquote><p>上面的解释可能还是有些抽象，但是通俗地解释方式就是：线程是进程的一个单元，如果把进程比作一座工厂，线程类似于工厂中的工人</p><p>这个比喻引用于<a href="https://zhuanlan.zhihu.com/p/403313422">此链接（点击跳转）</a>，可以在这里了解更多详细知识</p></blockquote><h3 id="OpenMP-是什么？"><a href="#OpenMP-是什么？" class="headerlink" title="OpenMP 是什么？"></a><code>OpenMP</code> 是什么？</h3><p><code>OpenMP</code> 是一套支持跨平台的共享内存方式的多线程并发的编程 <code>API</code></p><p>可以理解为，OpenMP 就是一套可以插入在代码中的工具，我们利用这些工具来实现一些多线程相关的功能。</p><p><code>OpenMP</code> 基于 <code>Fork</code> 、<code>Join</code> 模型，如下：</p><center><img src = https://s1.ax1x.com/2022/08/31/v4vuct.png width = 80%></center><p>如图主线程 <code>master thread</code> 在进入并行区域（<code>parallel region</code>）时，线程会被分岔（<code>fork</code>），在并行区域（<code>parallel region</code>）结束后，这些线程最终又会合并（<code>join</code>）</p><p>而简化地说，<code>OpenMP</code> 的作用就是指导编译器应该在何时、以何种方式（细节）将程序编译，让编译器在可行的范围内实现更加高效的操作</p><p>可以大致认为，<code>OpenMP</code> 的语法包括以下三类：</p><ul><li>线程相关的函数调用库</li><li>线程相关的编译指导语句</li><li>线程相关的环境变量</li></ul><p><code>OpenMP</code> 的执行有以下这些特点：</p><ul><li>OpenMP程序串行和并行区域交替出现</li><li>串行区域由 <code>master thread</code>（<code>thread 0</code>） 执行</li><li>并行区域由多个线程同一时间一起执行，不同线程一起完成并行区域中的任务</li></ul><p>如下图展示了语法执行的特点</p><center><img src = https://s1.ax1x.com/2022/08/31/v4vKjP.png width = 35%></center><h1 id="常用线程相关的函数调用库"><a href="#常用线程相关的函数调用库" class="headerlink" title="常用线程相关的函数调用库"></a>常用线程相关的函数调用库</h1><p><code>OpenMP</code> 的函数调用库可以用来进行一些进程相关的设置和信息获取。</p><p><code>OpenMP</code> 函数调用库的语法就是常规的函数调用语法，这个非常简单，这里就简单罗列几个函数并给出使用示例，只要看下面代码中的注释即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;omp.h&gt;</span></span><br><span class="line"><span class="built_in">omp_set_num_threads</span>(<span class="number">3</span>); <span class="comment">// 设置进程的线程数为 3（在此后的分支区，一共会有三个线程参与进行）</span></span><br><span class="line"><span class="type">int</span> thread_num = <span class="built_in">omp_get_thread_num</span>(); <span class="comment">// 获取当前进程中的线程数，此处 thread_num = 3</span></span><br><span class="line"><span class="function"><span class="type">int</span> mex_thread_num <span class="title">omp_get_mex_thread</span><span class="params">()</span></span>; <span class="comment">// 获取最多可以用于并行计算的线程数目</span></span><br><span class="line"><span class="type">int</span> thread_id = <span class="built_in">omp_get_thread_num</span>();  <span class="comment">// 获取当前线程的 id</span></span><br><span class="line"><span class="type">int</span> curTime = <span class="built_in">omp_get_wtime</span>(); <span class="comment">// 获取当前时间，秒为单位</span></span><br><span class="line"><span class="type">int</span> is_in_parallel = <span class="built_in">omp_in_parallel</span>(); <span class="comment">// 当前程序是否在并行中，1 表示并行，0表示串行</span></span><br></pre></td></tr></table></figure><h1 id="常用编译指导语句"><a href="#常用编译指导语句" class="headerlink" title="常用编译指导语句"></a>常用编译指导语句</h1><h2 id="编译指导语句的作用"><a href="#编译指导语句的作用" class="headerlink" title="编译指导语句的作用"></a>编译指导语句的作用</h2><p>编译指导语句在于告知编译器：</p><ul><li>哪些代码段应该并行进行</li><li>在并行进行的代码段中变量的属性是什么<blockquote><p>线程公有？线程私有？初始值应该如何确定？</p></blockquote></li><li>并行过程应该如何完成？各个线程应该如何配合和避免竞争</li></ul><blockquote><p>如果编译指导语句语法不对，会被当作一条注释</p></blockquote><h2 id="编译指导语句的格式"><a href="#编译指导语句的格式" class="headerlink" title="编译指导语句的格式"></a>编译指导语句的格式</h2><p>格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp 指令 [子句1] [子句2] [...]</span><br></pre></td></tr></table></figure></p><blockquote><p>注：<code>[]</code> 表示可选</p></blockquote><p>解释一下指令和子句指的都是什么——</p><ul><li>指令：规定并指派线程相关的功能</li><li>子句：配合指令，完善功能的细节，辅助指令达成线程相关的任务</li></ul><p>这样解释可能还不够明晰，但是只需要先记住调用的格式，下面结合具体代码进行解释——依葫芦画瓢永远是最快的学习手段</p><h2 id="编译指导语句常用指令"><a href="#编译指导语句常用指令" class="headerlink" title="编译指导语句常用指令"></a>编译指导语句常用指令</h2><h3 id="parallel-指令"><a href="#parallel-指令" class="headerlink" title="parallel 指令"></a><code>parallel</code> 指令</h3><p><code>parallel</code> 用在一个结构块之前，表示这段代码将被多个线程并行执行；</p><p>所谓结构块，就是用花括号框起来的代码块（如果只有一句，可以不框）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">omp_set_num_threads</span>(<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>终端显示的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">hhh, here is thread 1</span><br></pre></td></tr></table></figure><blockquote><p>不同次的调用得到的结果并不一样，说明线程并不是每次按固定的顺序先后进行的</p><p>而是 $3$ 个线程在同一段时间中同时调用了 <code>printf</code> 函数，<code>parallel</code> 块中的每行代码都被 $3$ 个线程重复执行。</p></blockquote><p>简单地说，<code>parallel</code> 的作用就是划定一块并行区域。</p><p>了解了 <code>parallel</code> 指令的语法，其它指令也和它类似，我们可以学得稍微快点了~</p><h3 id="for-指令"><a href="#for-指令" class="headerlink" title="for 指令"></a><code>for</code> 指令</h3><p><code>for</code> 指令一般使用在并行域（外部嵌套有 <code>parallel</code>）中，其作用是让多个线程完成<strong>同一个循环</strong>。</p><p><code>for</code> 指令可以直接和 <code>parallel</code> 连用，既创建并行区域，又指导线程共同完成循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出的结果只有三行，也就是一次 <code>for</code> 循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">hhh, here is thread 0</span><br></pre></td></tr></table></figure><p>事实上，<code>for</code> 也可以单独使用，比如上面的语句可以修改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个语句中我们先划定并行区，然后让多个线程合作完成<strong>一次</strong> <code>for</code> 循环，和 <code>parallel for</code> 效果一致</p></blockquote><h3 id="sections"><a href="#sections" class="headerlink" title="sections"></a><code>sections</code></h3><p><code>sections</code> 指令一般使用在并行域（外部嵌套有 <code>parallel</code>）中，并且可以和 <code>parallel</code> 连用，成为 <code>parallel sections</code></p><p><code>sections</code> 的作用是划定一块代码区域，在代码区域内指定 <code>section</code> 代码块，不同的线程将会执行不同的代码块，通过这种方式来指导线程进行分工。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel sections</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and section 1\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and section 2\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and section 3\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe </span><br><span class="line">hhh, here is thread 2 and section 3</span><br><span class="line">hhh, here is thread 2 and section 3</span><br><span class="line">hhh, here is thread 2 and section 3</span><br><span class="line">hhh, here is thread 1 and section 1</span><br><span class="line">hhh, here is thread 1 and section 1</span><br><span class="line">hhh, here is thread 1 and section 1</span><br><span class="line">hhh, here is thread 0 and section 2</span><br><span class="line">hhh, here is thread 0 and section 2</span><br><span class="line">hhh, here is thread 0 and section 2</span><br></pre></td></tr></table></figure><p>可见：每个线程会负责一个代码块，不同线程负责不同的代码块，代码块中不会受到其它代码块的干扰</p><blockquote><p>和 <code>for</code> 一样，<code>sections</code> 也能写成单独列出，嵌套在外层 <code>parallel</code> 中的形式 </p><p>注意：没有加 <code>parallel</code> 的 <code>sections</code> 里面的 <code>section</code> 是串行的</p></blockquote><h3 id="single-和-master"><a href="#single-和-master" class="headerlink" title="single 和 master"></a><code>single</code> 和 <code>master</code></h3><p><code>single</code> 和用在并行域内（外部嵌套有 <code>parallel</code>），表示一段只被单个线程执行的代码；</p><ul><li>使用 <code>single</code> 时执行这段代码的线程不一定是 <code>master</code> （编号为 $0$）线程，而是第一个到达 <code>single</code> 语句的线程，具有一定随机性；</li><li>而使用 <code>master</code> 时执行这段代码的线程一定是 <code>master</code> 线程。</li></ul><blockquote><p>在 <code>single</code> 和 <code>master</code> 划定的代码块执行时，其他的线程会等待直到 <code>single</code> 和 <code>master</code> 语句对应的区域执行完成</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp master</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;master %d\n run&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the only thread to run single is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">master 0 run</span><br><span class="line">master 0 run</span><br><span class="line">master 0 run</span><br><span class="line">the only thread to run single is 1</span><br><span class="line">the only thread to run single is 1</span><br><span class="line">the only thread to run single is 1</span><br></pre></td></tr></table></figure></p><h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a><code>flush</code></h3><p><code>flush</code> 保证各个 <code>OpenMP</code> 线程的数据影像的一致性</p><p>由于比较少主动使用该命令，在这里仅作简单介绍</p><h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a><code>barrier</code></h3><p><code>barrier</code> 用于并行域内代<code>barrier</code>码的线程同步，线程执行到 <code>barrier</code> 时要停下等待，直到所有线程都执行到barrier时才继续往下执行</p><p>如下代码，会在所有线程都执行完 <code>barrier</code> 前的语句后才执行 <code>barrier</code> 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d cross barrier\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">thread 2 cross barrier</span><br><span class="line">thread 0 cross barrier</span><br><span class="line">thread 1 cross barrier</span><br></pre></td></tr></table></figure><p>如果我们把 <code>barrier</code> 相关语句去掉，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>会得到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">thread 0</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">thread 1</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">thread 2</span><br></pre></td></tr></table></figure><p>可以观察到线程之间并不同步。</p><blockquote><p><code>parallel</code> 和 <code>for</code> 创建区域结束时都有隐式同步 <code>barrier</code></p></blockquote><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a><code>atomic</code></h3><p><code>atomic</code> 用于指定一个数据操作需要原子性地完成。即保证内存中的共享存储变量在某时刻只被同一线程修改。</p><p>这里指的数据操作就是类似于 <code>++</code>、<code>--</code> 这类操作，而比如在 <code>#pragma omp atomic</code> 语句下调用 <code>printf</code> 语句会得到一个报错。</p><p>如下，是添加了 <code>atomic</code> 语句的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(a)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp atomic</span></span><br><span class="line">        ++a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d : ++a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : ++a is 2</span><br><span class="line">thread 1 : ++a is 1</span><br><span class="line">thread 2 : ++a is 3</span><br></pre></td></tr></table></figure><p>不添加 <code>atomic</code> 语句则输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : ++a is 1</span><br><span class="line">thread 1 : ++a is 2</span><br><span class="line">thread 2 : ++a is 1</span><br></pre></td></tr></table></figure><p><code>++a</code> 被混乱执行，可能导致如上错误</p><blockquote><p>虽然有些时候能得到正确的结果，但是这一风险的出现是随机的</p></blockquote><h3 id="critical"><a href="#critical" class="headerlink" title="critical"></a><code>critical</code></h3><p><code>critical</code> 用在一段代码临界区之前，保证每次只有一个 <code>OpenMP</code> 线程进入，即保证程序的特定区域一次（时刻）只有一个线程执行</p><p><code>critical</code> 的作用和 <code>atomic</code> 非常相似，区别是 <code>atomic</code> 只作用于单个数据操作（原子操作），而 <code>critical</code> 作用域是一段代码块</p><p>如下，<code>critical</code> 调用 <code>printf</code> 函数不会再像 <code>atomic</code> 得到报错，理论上，只要是正确的代码块都可以使用 <code>critical</code> 划定区域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(a)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        &#123;</span><br><span class="line">            a++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread %d : ++a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，三个线程合作完成了循环，但是每层循环只有一个线程进入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : ++a is 1</span><br><span class="line">thread 2 : ++a is 2</span><br><span class="line">thread 1 : ++a is 3</span><br></pre></td></tr></table></figure><h3 id="threadprivate-指令"><a href="#threadprivate-指令" class="headerlink" title="threadprivate 指令"></a><code>threadprivate</code> 指令</h3><p><code>threadprivate</code> 用于指定一个或多个变量是线程专用，将全局变量的副本与线程绑定，即使跨越多个并行区域这种关系也不会改变。</p><p>简单而言，就是为每个线程定义私有变量时增加一个<strong>保留</strong>性质——</p><p>假设有一个变量 <code>a</code> 经过了 <code>threadprivate(a)</code> 处理，<strong>保留</strong>就是让并行区域结束以后线程中的私有变量不被清除，它的值仍然被相应的线程“记忆”，并且可以在下一个并行区域中调用。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(a)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">omp_set_num_threads</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">omp_set_dynamic</span>(<span class="number">0</span>); <span class="comment">// 关闭动态线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel    <span class="comment">// 第一个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">// 第二个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d : a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意 1 ：<code>a</code> 应该设置成一个全局变量否则会被编译器报错</p><p>注意 2 ：使用 <code>threadprivate</code> ，必须关闭动态线程机制，同时不同并行区域中的线程数保持不变</p></blockquote><p>得到的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : a is 0</span><br><span class="line">thread 2 : a is 2</span><br><span class="line">thread 1 : a is 1</span><br></pre></td></tr></table></figure><p>可以观察到尽管在第二个并行区域并行区域中并没有给变量 <code>a</code> 赋值，但是变量 <code>a</code> 的值还是<strong>保留</strong>了第一个并行区域的设置结果</p><h2 id="编译指导语句的子句"><a href="#编译指导语句的子句" class="headerlink" title="编译指导语句的子句"></a>编译指导语句的子句</h2><h3 id="private-子句"><a href="#private-子句" class="headerlink" title="private 子句"></a><code>private</code> 子句</h3><blockquote><p>以下是关于数据共享和保护的子句</p><p>数据共享：共享的数据可以在多个线程中使用</p><p>数据保护：被保护的数据只能在个别线程中使用</p></blockquote><ul><li><code>private</code>：该子句声明列表中的所有变量都是进程私有的（变量列表列举在尾随圆括号中），如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;   <span class="comment">// 先对 x 进行定义</span></span><br><span class="line"><span class="meta">#progma omp parallel private(x)</span></span><br></pre></td></tr></table></figure><blockquote><p>声明称线程私有变量以后，每个线程都有一个该变量的副本，这些副本可以有不相同的值，并且线程之间对这些值的操作不会互相影响</p><p>注意1：原变量在并行部分不起任何作用，原变量也不会受到并行部分内部操作的影响——并行部分操作的始终不是原变量的<strong>本体</strong>，有点类似于函数的“值传递”</p><p>注意2：<code>private</code> 子句的本质只是为了名字的重用——它创建的变量储存在相应线程的栈中，而不是公共的区域。在我的系统上，如果不对私有变量进行赋值，它将被默认初始化为 $0$</p><p>受到这样的启发——我们是不是可以把线程看作是可以由我们任意指派运行时机（同时运行、先后运行）的函数呢？至少当前可以通过这样理解解释一些知识</p></blockquote><p>下面这段代码中，<code>a</code> 变量在创建以后被声明为线程私有，每个线程中的 <code>a</code> 经过各自的自增操作，因此它们的值都是 <code>2</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        a++;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0 and a is 2</span><br><span class="line">hhh, here is thread 2 and a is 2</span><br><span class="line">hhh, here is thread 1 and a is 2</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，在并行区域中定义的变量属于私有变量</p></blockquote><h3 id="firstprivate"><a href="#firstprivate" class="headerlink" title="firstprivate"></a><code>firstprivate</code></h3><p><code>firstprivate</code> 的特性和 <code>private</code> 基本一致，只是多了一个附加功能——它能把所有线程私有变量（也就是原变量的副本）的初始值都设置成原变量的值，相当于 <code>private</code> 加一个初始化</p><p>将 <code>private</code> 例子的代码修改为： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel firstprivate(a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a++;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0 and a is 4</span><br><span class="line">hhh, here is thread 2 and a is 4</span><br><span class="line">hhh, here is thread 1 and a is 4</span><br></pre></td></tr></table></figure><h3 id="lastprivate"><a href="#lastprivate" class="headerlink" title="lastprivate"></a><code>lastprivate</code></h3><p><code>lastprivate</code> 的特性和 <code>private</code> 基本一致，只是多了一个附加功能——它能在退出并行部分时将计算结果赋值回原变量。</p><p>规则很好理解，但是这里就会导致一个问题：如果所有线程同时操作一个变量，究竟将哪个线程操作后的变量值赋值给原变量？</p><p><code>OpenMP</code> 规范明确了这一点——在 <code>for</code> 循环迭代中，将程序语法逻辑上最后一次迭代的值赋值给原变量；在 <code>sections</code> 结构，将程序语法上的最后一个 <code>section</code> 语句赋值给原变量。</p><p>下面代码演示了这一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(a), lastprivate(a)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a += i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0 and a is 1</span><br><span class="line">hhh, here is thread 2 and a is 3</span><br><span class="line">hhh, here is thread 1 and a is 2</span><br><span class="line">at last, a is 3</span><br></pre></td></tr></table></figure><h3 id="shared-子句"><a href="#shared-子句" class="headerlink" title="shared 子句"></a><code>shared</code> 子句</h3><p>该子句用于声明变量列表中的所有变量都是进程公共的。</p><p>一般情况下，除非逻辑上非常严密，或者对变量有着严格的保护，否则使用 <code>shared</code> 子句都是需要非常谨慎的，比如下面的代码看上去就运行得不是那么理想——</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(a)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a += i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d, a is %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at last, a is %d\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hhh, here is thread 2, a is 9 and i is 3</span><br><span class="line">hhh, here is thread 0, a is 4 and i is 1</span><br><span class="line">hhh, here is thread 1, a is 6 and i is 2</span><br><span class="line">at last, a is 9</span><br></pre></td></tr></table></figure><blockquote><p><code>shared</code> 的子句是带有继承初值和将最终值传回给原变量的作用的</p></blockquote><h3 id="default-子句"><a href="#default-子句" class="headerlink" title="default 子句"></a><code>default</code> 子句</h3><p><code>default</code> 子句用来指定并行域内的变量的使用方式</p><p><code>default(shared)</code> 子句将所有并行区域外的变量的数据共享属性设置为共享</p><blockquote><p>注意：循环变量和在并行区域内声明的变量不受 <code>default(shared)</code> 影响</p></blockquote><p><code>default(none)</code> 子句并不设置变量的数据共享属性，但是它会强制程序员去指定所有变量的数据共享属性以确保程序的正确性</p><p>在上面已经详细解释过了数据共享属性的涵义，这里不再贴代码。</p><h3 id="copyin-子句"><a href="#copyin-子句" class="headerlink" title="copyin 子句"></a><code>copyin</code> 子句</h3><p>而 <code>copyin</code> 子句专门用于 <code>threadprivate</code> 变量，可以为所有线程的 <code>threadprivate</code> 变量分配相同的值。</p><p>用 <code>copyin</code> 子句设置的 <code>threadprivate</code> 变量，在进入并行区域时，会用主线程变量值为每个线程的该变量副本初始化。</p><p>如下代码所示，所有线程中储存的副本变量 <code>a</code> 都会被修改为 <code>0</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(a)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">omp_set_num_threads</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">omp_set_dynamic</span>(<span class="number">0</span>); <span class="comment">// 关闭动态线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel    <span class="comment">// 第一个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel copyin(a)<span class="comment">// 第二个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d : a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try.exe</span><br><span class="line">thread 2 : a is 0</span><br><span class="line">thread 0 : a is 0</span><br><span class="line">thread 1 : a is 0</span><br></pre></td></tr></table></figure><h3 id="reduction-子句"><a href="#reduction-子句" class="headerlink" title="reduction 子句"></a><code>reduction</code> 子句</h3><p><code>reduction</code> 子句相当于两个过程——</p><ul><li>在每个线程为全局的原始变量创建属性为 <code>private</code> 的线程局部变量副本</li><li>将各个线程的局部变量副本进行指定的操作，并将操作后的结果返回全局的原始变量</li></ul><p><code>reduction</code> 子句的语法结构是这样的：<code>reduction(操作符 : 进行该操作的变量列表)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel reduction(+ : a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a += i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d, a is %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at last, a is %d\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>上述代码经历的过程是这样的：</p><p>先将 <code>a</code> 变量拷贝到每个线程中作为线程私有变量，每个线程中初始化为 <code>4</code></p><p>然后线程共同完成 <code>for</code> 循环，即三个线程中的 <code>a</code> 分别加上 <code>1</code>、<code>2</code> 和 <code>3</code> 而得到 <code>5</code>、<code>6</code> 和 <code>7</code></p><p>然后进行 <code>reduction</code> 操作，即加和操作——全局的原始变量 <code>a</code> = <code>2 + 5 + 6 + 7 = 20</code>，因此代码运行结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0, a is 5 and i is 1</span><br><span class="line">hhh, here is thread 2, a is 7 and i is 3</span><br><span class="line">hhh, here is thread 1, a is 6 and i is 2</span><br><span class="line">at last, a is 20</span><br></pre></td></tr></table></figure><h3 id="nowait-子句"><a href="#nowait-子句" class="headerlink" title="nowait 子句"></a><code>nowait</code> 子句</h3><p>上面介绍 <code>barrier</code> 时提到： <code>parallel</code> 和 <code>for</code> 创建区域结束时都有隐式同步 <code>barrier</code></p><p><code>nowait</code> 子句即用于取消 <code>parallel</code> 和 <code>for</code> 中的默认隐含 <code>barrier</code> ，使一个线程完成指定工作后无需等待其它线程，直接进行后续的工作，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">// 第一个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for nowait</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread %d : hhh\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d : www\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : hhh</span><br><span class="line">thread 0 : www</span><br><span class="line">thread 1 : hhh</span><br><span class="line">thread 1 : www</span><br><span class="line">thread 2 : hhh</span><br><span class="line">thread 2 : www</span><br></pre></td></tr></table></figure><p>可以发现各线程跑完 <code>for</code> 中的相关任务就直接继续执行 <code>printf(&quot;thread %d : www\n&quot;, omp_get_thread_num());</code> 了，并没有进行停留，如果去掉 <code>nowait</code>，得到的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 2 : hhh</span><br><span class="line">thread 0 : hhh</span><br><span class="line">thread 1 : hhh</span><br><span class="line">thread 0 : www</span><br><span class="line">thread 1 : www</span><br><span class="line">thread 2 : www</span><br></pre></td></tr></table></figure><h3 id="num-threads-子句"><a href="#num-threads-子句" class="headerlink" title="num_threads 子句"></a><code>num_threads</code> 子句</h3><p><code>num_threads(cnt)</code> 效果等同函数 <code>omp_set_num_threads(cnt)</code>，不进行详述。</p><h3 id="schedule-子句"><a href="#schedule-子句" class="headerlink" title="schedule 子句"></a><code>schedule</code> 子句</h3><p><code>schedule</code> 子句的语法规则是：<code>schedule(strategy, chunk_size)</code></p><p><code>schedule</code> 子句用来描述如何将循环迭代划分给一组线程，包含三种方式：</p><ul><li><code>static</code> ：<code>static</code> 划分策略会将循环迭代被分成多个块，块的大小 <code>chunk_size</code> 由程序员指定，然后线程的顺序静态地分配给各线程</li></ul><blockquote><p>如果未指定块大小，则循环迭代将在线程之间尽量均匀连续地划分</p></blockquote><ul><li><p><code>dynamic</code>：<code>dynamic</code> 划分策略会将循环迭代被分成多个块，块的大小 <code>chunk_size</code> 由程序员指定，各线程完成对应的块后会申请执行新的块</p></li><li><p><code>guided</code>：<code>guided</code> 划分策略采用指导性的启发式自调度方法，开始时每个线程会分配到较大的迭代块，之后分配到的迭代块会逐渐递减。迭代块的大小会按指数级下降到指定的块大小，这个指定的块大小 <code>chunk_size</code> 可以由程序员自行指定</p></li></ul><p>如下，我们运行一下 <code>static</code> 的代码——</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for schedule(static)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0 and i is 1</span><br><span class="line">hhh, here is thread 0 and i is 2</span><br><span class="line">hhh, here is thread 0 and i is 3</span><br><span class="line">hhh, here is thread 1 and i is 4</span><br><span class="line">hhh, here is thread 1 and i is 5</span><br><span class="line">hhh, here is thread 1 and i is 6</span><br><span class="line">hhh, here is thread 2 and i is 7</span><br><span class="line">hhh, here is thread 2 and i is 8</span><br></pre></td></tr></table></figure><p><code>dynamic</code> 的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for schedule(dynamic, 3)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 1 and i is 7</span><br><span class="line">hhh, here is thread 1 and i is 8</span><br><span class="line">hhh, here is thread 1 and i is 9</span><br><span class="line">hhh, here is thread 1 and i is 10</span><br><span class="line">hhh, here is thread 1 and i is 11</span><br><span class="line">hhh, here is thread 2 and i is 1</span><br><span class="line">hhh, here is thread 2 and i is 2</span><br><span class="line">hhh, here is thread 2 and i is 3</span><br><span class="line">hhh, here is thread 2 and i is 13</span><br><span class="line">hhh, here is thread 2 and i is 14</span><br><span class="line">hhh, here is thread 2 and i is 15</span><br><span class="line">hhh, here is thread 1 and i is 12</span><br><span class="line">hhh, here is thread 0 and i is 4</span><br><span class="line">hhh, here is thread 0 and i is 5</span><br><span class="line">hhh, here is thread 0 and i is 6</span><br></pre></td></tr></table></figure><p><code>guided</code> 的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for schedule(guided)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try.exe</span><br><span class="line">hhh, here is thread 0 and i is 6</span><br><span class="line">hhh, here is thread 0 and i is 7</span><br><span class="line">hhh, here is thread 0 and i is 8</span><br><span class="line">hhh, here is thread 0 and i is 9</span><br><span class="line">hhh, here is thread 0 and i is 12</span><br><span class="line">hhh, here is thread 0 and i is 13</span><br><span class="line">hhh, here is thread 0 and i is 14</span><br><span class="line">hhh, here is thread 0 and i is 15</span><br><span class="line">hhh, here is thread 1 and i is 1</span><br><span class="line">hhh, here is thread 1 and i is 2</span><br><span class="line">hhh, here is thread 1 and i is 3</span><br><span class="line">hhh, here is thread 1 and i is 4</span><br><span class="line">hhh, here is thread 1 and i is 5</span><br><span class="line">hhh, here is thread 2 and i is 10</span><br><span class="line">hhh, here is thread 2 and i is 11</span><br></pre></td></tr></table></figure><p>事实上，它们的区别可能从输出结果上并看不出什么，但是内在的循环进行和迭代的策略是有所不同的</p><h3 id="ordered-子句"><a href="#ordered-子句" class="headerlink" title="ordered 子句"></a><code>ordered</code> 子句</h3><p>让 <code>for</code> 循环按照预期的逻辑和顺序运行</p><blockquote><p>待续</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021届信息学院暑期编程集训</title>
      <link href="/2022/08/31/%E7%BC%96%E7%A8%8B%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/08/31/%E7%BC%96%E7%A8%8B%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本次编程集训的两个比较重要的任务是五子棋 <code>AI</code> 算法设计和贪吃蛇算法设计</p><p>两个游戏的共同点是：</p><ul><li><p>系统每次都会传给程序当前的游戏状态，而程序每次都重新调用——因此程序是没有“记忆”的：只能得到当前的状态，无法获取当前状态是经过了什么演变得到的</p></li><li><p>AI 的目标都是根据当前的场景作出最有利的决策——就是需要根据当前的状态进行一定的“对局面的预测”，使得即使不能获取局势的演变信息也能作出比较长远的估计</p></li></ul><h1 id="五子棋算法设计思路"><a href="#五子棋算法设计思路" class="headerlink" title="五子棋算法设计思路"></a>五子棋算法设计思路</h1><h2 id="落子权值估计"><a href="#落子权值估计" class="headerlink" title="落子权值估计"></a>落子权值估计</h2><p>落子的权值估计主要通过考虑各种情形的“价值”，五子棋中比较常规的棋形可以归结为下面几种：</p><p>五连、活四、单四、活三、单三、活二、单二、活一、单一……</p><p>此外，有几种棋形具有特殊的优势：</p><ul><li>两个单四的组合</li><li>单四和活三的组合</li><li>两个活三的组合</li></ul><p>在这三种情况下，原有的棋形会具有更高的威胁，因此应该为它们加上额外的 <code>BUFF</code> 分值，让 <code>AI</code> 能够更加贴合实际中的场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*六连的返回值为</span></span><br><span class="line"><span class="type">int</span> Large_Than_Six = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*以下三个值作为基准值,它们都是必胜局面的情形*//</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Five_1 = <span class="number">500000</span>; <span class="comment">//*(1)如果将棋子放在这个位置,会产生一个五连,那么威力值设置为 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*必杀棋形</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Live_Four_1 = <span class="number">10000</span>;       <span class="comment">//*(2)如果将棋子放在这个位置,未产生(1),但产生一个活四,威力值设置为 1000</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Single_Four_2_BUFF = <span class="number">7000</span>; <span class="comment">//*(3)如果将棋子放在这个位置,不会产生(1)(2),但是会产生两个单四,其威力值设置为 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*准必杀棋形 BUFF 在原有基准上如果满足这种</span></span><br><span class="line"><span class="comment">//*下面两个值是即将会产生必胜局面的情形,不论哪方造成威力都很大,因此不区分自己和对手*//</span></span><br><span class="line"><span class="comment">//*这些值由九个基因进行训练,数据灵敏度 2,数据范围 2 - 1024</span></span><br><span class="line"><span class="type">int</span> Single_Four_1_And_Live_Three_1_BUFF = <span class="number">5000</span>; <span class="comment">//*(4)如果将棋子放在这个位置,不会产生(1)(2)(3)而会产生一个单四和一个活三</span></span><br><span class="line"><span class="type">int</span> Live_Three_2_BUFF = <span class="number">4900</span>;                   <span class="comment">//*(5)如果将棋子放在这个位置,不会产生上述情况,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*下面这些情况需要区分对手的收益和自己的收益</span></span><br><span class="line"><span class="comment">//*这些值由七个基因进行训练,数据灵敏度 2,数据范围 2 - 256</span></span><br><span class="line"><span class="type">int</span> My_Single_Four = <span class="number">5500</span>;       <span class="comment">//*(6)我方单四</span></span><br><span class="line"><span class="type">int</span> Opposite_Single_Four = <span class="number">5500</span>; <span class="comment">//*(7)对方单四</span></span><br><span class="line"><span class="type">int</span> My_Live_Three = <span class="number">3000</span>;        <span class="comment">//*(8)我方活三</span></span><br><span class="line"><span class="type">int</span> Opposite_Live_Three = <span class="number">3000</span>;  <span class="comment">//*(9)对方活三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*下面这些情况的威胁很低,不需要区分对手的收益和自己的收益</span></span><br><span class="line"><span class="type">int</span> Single_Three = <span class="number">500</span>; <span class="comment">//*(10)单三</span></span><br><span class="line"><span class="type">int</span> Live_Two = <span class="number">100</span>;     <span class="comment">//*(11)活二</span></span><br><span class="line"><span class="type">int</span> Single_Two = <span class="number">50</span>;    <span class="comment">//*(12)单二</span></span><br><span class="line"><span class="type">int</span> Live_One = <span class="number">1</span>;       <span class="comment">//*(13)活一</span></span><br><span class="line"><span class="type">int</span> Single_One = <span class="number">1</span>;     <span class="comment">//*(14)单一</span></span><br></pre></td></tr></table></figure><p>而评估函数的设计方法是：</p><ul><li>遍历棋盘的每一个斜行、每一个横行、每一个竖列——找到棋盘中的各种上述棋形，然后将它们进行加和，作为一个棋盘状态的“价值”</li><li>我们的落子应该使得两个状态之间的价值差最大化</li></ul><p>评估函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValueSum</span><span class="params">(PieceColor cur_player_color, Board tempBoard)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> valueSum = <span class="number">0</span>; <span class="comment">//*棋盘上各种棋型的价值总和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! pieceType必须采用指针传参的形式以保证pieceType的值能被记录</span></span><br><span class="line">    Type **piecesType = <span class="keyword">new</span> Type *[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        piecesType[i] = <span class="keyword">new</span> Type[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有横行是否出现目标情形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">                <span class="comment">//!如果已经达到最后一个子并且数组中还有值,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*如果尺寸为0,不进行清算,这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有竖列是否出现目标情形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入连续棋子</span></span><br><span class="line">            <span class="keyword">if</span> (tempBoard.pieces[j][i].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[j][i]);</span><br><span class="line">                <span class="comment">//!如果已经达到最后一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是我的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有撇斜行是否出现目标情形</span></span><br><span class="line">    <span class="comment">//*假设坐标为 (i,j), j = i + b, 每取一个 b 就是探索一个斜行,一共 29 斜行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-14</span>; b &lt;= <span class="number">14</span>; b++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++) <span class="comment">//!读取一个斜行的所有可读值并进行判定与加和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + b;</span><br><span class="line">            <span class="comment">//!如果已经达到是一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    front_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    end_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; <span class="number">14</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有捺斜行是否出现目标情形</span></span><br><span class="line">    <span class="comment">//*假设坐标为 (i,j), j = -i + b, 每取一个 b 就是探索一个斜行,一共 29 斜行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">28</span>; b++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = -i + b;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//!如果已经达到是一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    front_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    end_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; <span class="number">14</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//!用于当一个节点的类型为 Single_Four 或 Live_Three 时,加入绝杀 BUFF</span></span><br><span class="line">    valueSum += <span class="built_in">getBuffValue</span>(piecesType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] piecesType; <span class="comment">//!每次使用时 piecesType 重新定义并及时删除,防止内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> valueSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述分值的确认值来自于网上的估计和相关资料的查阅，但是实际情况来看并不完全适用于真实对战中的场景</p><p>过程中也有过先在本地搭建一个五子棋平台，然后通过已有算法作为陪练对参数（估值）使用自适应的遗传算法进行参数优化，但是因为时间紧促，考虑到每局耗时过长，很难争取到足够的训练时间，遂放弃。</p><h2 id="Alpha-Beta-剪支算法框架"><a href="#Alpha-Beta-剪支算法框架" class="headerlink" title="Alpha-Beta 剪支算法框架"></a><code>Alpha-Beta</code> 剪支算法框架</h2><p>对抗搜索是一种可以在理论上寻找到完美策略的策略，这里不作详细介绍，仅简单总结一下基于本次五子棋 <code>AI</code> 开发任务设计的 <code>Alpha-Beta</code> 剪支算法框架</p><p>本次采用的 <code>Alpha-Beta</code> 剪支算法框架流程如下：</p><p>首先介绍一下针对五子棋对抗搜索算法设计的数据结构 <code>Node</code>，具体的数据涵义已经在代码注释中说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">structNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;         <span class="comment">//!用minmax计算的当前节点的价值</span></span><br><span class="line">    Pos place;         <span class="comment">//!基于当前的棋盘状态,应该选择哪个点</span></span><br><span class="line">    NodeType nodeType; <span class="comment">//!当前节点是最大值节点还是最小值节点</span></span><br><span class="line">    Board board;       <span class="comment">//!当前的棋盘状态</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">structNode</span>(Board board, NodeType nodeType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;board = board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodeType = nodeType;</span><br><span class="line">        <span class="keyword">this</span>-&gt;place.row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;place.col = <span class="number">0</span>;</span><br><span class="line">        value = (nodeType == my_max) ? max_LB : min_UB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><h3 id="alphaBetaSearch函数外：外层遍历-函数调用"><a href="#alphaBetaSearch函数外：外层遍历-函数调用" class="headerlink" title="alphaBetaSearch函数外：外层遍历 + 函数调用"></a><code>alphaBetaSearch</code>函数外：外层遍历 + 函数调用</h3><p>遍历每一个可能放置棋子的节点，对这些节点进行 <code>Alpha-Beta</code> 剪支算法搜索，并返回这些节点的最终估值</p><p>这些节点就是我们下一步要放置棋子的位置——所以它们应该是最大层节点，即 <code>nodeType = my_max</code>（节点的另一种属性是 <code>opposite_min</code>）</p><blockquote><p>事实证明：对抗搜索中，根据目的弄清楚初始节点的属性是 <code>my_max</code> 还是 <code>opposite_min</code> 非常重要</p></blockquote><p>我们刚刚已经提出，对一个节点的估值方法是——计算该节点对应的棋盘上我方棋子的总价值减去对方棋子的总价值</p><p>这样，最大层节点和最小层节点的目标也就一目了然了——最大层节点应使节点的 <code>value</code> 值尽量大，最小层节点应使节点的 <code>value</code>值尽量小</p><h3 id="alphaBetaSearch函数外：深度优先搜索-节点价值更新"><a href="#alphaBetaSearch函数外：深度优先搜索-节点价值更新" class="headerlink" title="alphaBetaSearch函数外：深度优先搜索 + 节点价值更新"></a><code>alphaBetaSearch</code>函数外：深度优先搜索 + 节点价值更新</h3><p>对抗搜索的框架和深度优先搜索的框架有一定相似性，准确地说，对抗搜索是深度搜索加入新特性的一种演变</p><p>我定义的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">alphaBetaSearch</span><span class="params">(<span class="type">const</span> Node &amp;lastNode, <span class="type">int</span> depth)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，<code>lastNode</code> 指的是上一层的节点，也就是上一层决策后的棋盘状态，而我们要往下传递的就是当前层的节点</p><p>首先根据上层节点的信息来对本层节点进行定义和赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node curNode = lastNode;</span><br><span class="line">curNode.nodeType = <span class="built_in">NodeType</span>(!lastNode.nodeType);</span><br><span class="line">curNode.value = (curNode.nodeType == my_max) ? curNode.max_LB : curNode.min_UB;</span><br></pre></td></tr></table></figure><p>然后和深度优先搜索一样，应该进行边界判断，当发现游戏结束或者达到搜索深度时应该估算并返回当前节点的价值，将这个价值向上传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!如果深度数值耗尽,则不再进行操作和向深处搜索,直接返回当前的节点及其价值</span></span><br><span class="line"><span class="keyword">if</span> (depth == <span class="number">0</span> || <span class="built_in">getValueSum</span>(myColor, lastNode.board) &gt;= <span class="number">500000</span> || <span class="built_in">getValueSum</span>(oppositeColor, lastNode.board) &gt;= <span class="number">500000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//!通过节点评估获取最后一层节点的准确价值,并直接返回</span></span><br><span class="line">    curNode.value = <span class="built_in">evaluateNode</span>(curNode);</span><br><span class="line">    <span class="comment">// check(returnNode.board);</span></span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如下图所示：只有最下面一层节点是可以通过对局面的状态估算得到确切价值，其它节点都是通过对抗搜索得到的</p><p><center><img src = https://s1.ax1x.com/2022/09/01/v5DbHe.jpg width = 60%>&lt;/cneter&gt;</p></blockquote><p>接下来应该获取每个可以放置棋子的位置，将这些位置整合到一个数组中等待遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Piece&gt; maybeChosenPiece; <span class="comment">//*可能会被遍历到的棋子</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//*如果一个位置的颜色为空并且附近有棋子</span></span><br><span class="line">        <span class="keyword">if</span> (lastNode.board.pieces[i][j].color == none &amp;&amp; <span class="built_in">havePieceNearby</span>(lastNode.board.pieces[i][j].pos, lastNode.board, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//*将这个位置作为一种选择放入可选序列中</span></span><br><span class="line">            <span class="comment">// pieceCnt++;</span></span><br><span class="line">            maybeChosenPiece.<span class="built_in">push_back</span>(lastNode.board.pieces[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后对这个存放可下棋位置的数组进行遍历，也就是在这些位置落子，然后将落子后的新状态作为 <code>lastNode</code> 参数，递归地调用 <code>alphaBetaSearch</code> 函数，得到这些落子情况下获得的棋盘状态价值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!遍历每个可能选择的棋子,向下进行限制深度的dfs</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> it : maybeChosenPiece)</span><br><span class="line">   &#123;</span><br><span class="line">       curNode.board.pieces[it.pos.row][it.pos.col].color = (curNode.nodeType == my_max) ? myColor : oppositeColor;</span><br><span class="line">       Node nextNode = <span class="built_in">alphaBetaSearch</span>(curNode, depth - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (curNode.nodeType == my_max) <span class="comment">//! 如果当前是最大值节点,就取下一层节点的最大值</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (curNode.value &lt; nextNode.value) <span class="comment">//!如果下一个节点返回的值大于当前节点的值,就对当前节点进行更新</span></span><br><span class="line">           &#123;</span><br><span class="line">               curNode.value = nextNode.value; <span class="comment">//!对当前节点的 value 值进行更新</span></span><br><span class="line">               curNode.place = it.pos;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="comment">//! 如果当前是最小值节点,就取下一层节点的最小值</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (curNode.value &gt; nextNode.value)</span><br><span class="line">           &#123;</span><br><span class="line">               curNode.value = nextNode.value;</span><br><span class="line">               curNode.place = it.pos;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//!回溯应该清洗状态：但更好的方法是更早地定义nextNode并且将修改都写在nextNode中</span></span><br><span class="line">       curNode.board.pieces[it.pos.row][it.pos.col].color = it.color; <span class="comment">//!还原这颗棋子本来的颜色</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure><blockquote><p>相对于深度优先搜索附加的并且非常重要的一点是：</p><p>在递归返回后的处理不仅包括状态回溯，还包括更新自身的的最优值（<code>max</code> 层则取 <code>max</code>，<code>min</code> 层则取 <code>min</code>），经过一个循环的最优值更新后，得到的 <code>curNode</code> 就是我们要返回的节点</p></blockquote><h2 id="算法加速和改进"><a href="#算法加速和改进" class="headerlink" title="算法加速和改进"></a>算法加速和改进</h2><p>上述给出的代码实际上 <code>min-max</code> 算法的代码，我们要对这个代码进行加速，实际上只需要加上几行代码进行剪枝，就能得到 <code>Alpha-Beta</code> 搜索算法</p><p>这里很重要的一点就是我们在传递节点的过程中，实际上也传递了上一层节点的 <code>lastNode.value</code> 值，</p><p>对于这个 <code>lastNode.value</code> 值的理解非常重要——</p><p>它相当于一个“指导值”，可以形象化地理解这个值：</p><blockquote><p>每一层节点都会向下一次层节点传递一个包含当前节点信息的节点，它就是下一层节点的 <code>lastNode</code> 参数</p><p>这个参数相当于一个指导值，比如下一层节点是 <code>max</code> 节点，那么如果 <code>max</code> 节点搜索到了一个比 <code>lastNode.value</code> 值大的结果，很显然，由于这个 <code>max</code> 节点要取自己所有子节点的最大值并返回，返回的值一定会大于 <code>lastNode.value</code> ，无法对 <code>lastNode.value</code> 照成改动，很显然这个 <code>max</code> 节点就是一个无效节点，直接剪枝是不会影响最终得到的结果的</p></blockquote><p>将上面的搜索代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!遍历每个可能选择的棋子,向下进行限制深度的dfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : maybeChosenPiece)</span><br><span class="line">    &#123;</span><br><span class="line">        curNode.board.pieces[it.pos.row][it.pos.col].color = (curNode.nodeType == my_max) ? myColor : oppositeColor;</span><br><span class="line">        Node nextNode = <span class="built_in">alphaBetaSearch</span>(curNode, depth - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curNode.nodeType == my_max) <span class="comment">//! 如果当前是最大值节点,就取下一层节点的最大值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &lt; nextNode.value) <span class="comment">//!如果下一个节点返回的值大于当前节点的值,就对当前节点进行更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                curNode.value = nextNode.value; <span class="comment">//!对当前节点的 value 值进行更新</span></span><br><span class="line">                curNode.place = it.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &gt; lastNode.value)</span><br><span class="line">                <span class="keyword">return</span> curNode; <span class="comment">//!剪掉的方式就是直接return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//! 如果当前是最小值节点,就取下一层节点的最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &gt; nextNode.value)</span><br><span class="line">            &#123;</span><br><span class="line">                curNode.value = nextNode.value;</span><br><span class="line">                curNode.place = it.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &lt; lastNode.value)</span><br><span class="line">                <span class="keyword">return</span> curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!回溯应该清洗状态：但更好的方法是更早地定义nextNode并且将修改都写在nextNode中</span></span><br><span class="line">        curNode.board.pieces[it.pos.row][it.pos.col].color = it.color; <span class="comment">//!还原这颗棋子本来的颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure><p>由于剪枝的方式实际上就是直接停止当前节点的搜索进程，直接返回当前节点。所以需要进行的改动也就是在 <code>max</code> 和 <code>min</code> 节点的情况中分别增加了一句判断返回代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curNode.value &gt; lastNode.value)</span><br><span class="line">    <span class="keyword">return</span> curNode; <span class="comment">//!剪掉的方式就是直接return</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curNode.value &lt; lastNode.value)</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure><p>另外，对于一些周围没有任何棋子的节点，我们没有必要进行搜索，一般情况下，不会有人会在这些位置落子，判断函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*该函数返回半径为 r 的范围内是否有棋子</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">havePieceNearby</span><span class="params">(Pos pos, Board tempBoard, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// check(tempBoard);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos.row - r; i &lt;= pos.row + r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = pos.col - r; j &lt;= pos.col + r; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">14</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="number">14</span>)</span><br><span class="line">                flag += (tempBoard.pieces[i][j].color != none); <span class="comment">//*如果这个位置有棋子,就将flag+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;flag is &quot; &lt;&lt; flag &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> (flag &gt; <span class="number">0</span>); <span class="comment">//!附近有棋子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一的对抗搜索模板"><a href="#统一的对抗搜索模板" class="headerlink" title="统一的对抗搜索模板"></a>统一的对抗搜索模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">alphaBetaSearch</span><span class="params">(<span class="type">const</span> Node &amp;lastNode, <span class="type">int</span> depth)</span></span>;</span><br></pre></td></tr></table></figure><p><code>lastNode</code>：上一层节点的状态</p><p><code>curNode</code>：当前节点状态</p><p><code>nextNode</code>：下一层节点的状态</p><p>关于 <code>Node</code> 的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">structNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;         <span class="comment">//!用minmax计算的当前节点的价值</span></span><br><span class="line">    Pos place;         <span class="comment">//!基于当前的棋盘状态,应该选择哪个点</span></span><br><span class="line">    NodeType nodeType; <span class="comment">//!当前节点是最大值节点还是最小值节点</span></span><br><span class="line">    Board board;       <span class="comment">//!当前的棋盘状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一步：进行边界判断，是否达到搜索深度或者博弈结局</p></li><li><p>第二步：搜索整个决策空间，将可行决策纳入一个数组中</p><blockquote><p>第二步有一定的剪枝空间，可以调整决策空间的大小</p></blockquote></li><li><p>第三步：遍历整个可行决策数组，对于每个可行决策，对 <code>curNode</code> 进行修改并作为参数调用 <code>alphaBetaSearch</code> ，将返回的节点作为 <code>nextNode</code></p></li><li><p>第四步：根据 <code>nextNode.value</code> 是否比 <code>curNode.value</code> 更优来决定是否对本层节点的 <code>value</code> 值进行更新</p></li><li><p>第五步：如果更新后的节点可以确认当层节点的 <code>curNode.value</code> 值一定不能达到对 <code>lastNode.value</code> 的修改条件，就直接剪枝（当场返回当前节点）</p></li><li><p>第六步：不满足第五步的操作条件，那么对 <code>curNode</code> 进行状态回溯，继续第三、四、五步的循环中的剩余部分，完成循环后， 则 <code>curNode.value</code> 已经被更新为最优值，返回。</p></li></ul><h1 id="贪吃蛇算法设计思路"><a href="#贪吃蛇算法设计思路" class="headerlink" title="贪吃蛇算法设计思路"></a>贪吃蛇算法设计思路</h1><h2 id="食物价值传播"><a href="#食物价值传播" class="headerlink" title="食物价值传播"></a>食物价值传播</h2><p>该贪吃蛇游戏的食物分布是遍布全图的，但是也会碰到这样一种尴尬的情况：就是一些在一些区域中自己的搜索范围内不存在任何的食物，这种情况很有可能就会导致蛇原地打转，非常影响发育。其次，即使有搜索能力，搜索范围过小也有可能导致蛇进入“短视”的状态，体现为它并不关心更远距离的高分值食物，而是只会追逐近距离的低分值食物。因此，引入了食物价值传播的函数——</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foodValueSpread</span><span class="params">(<span class="type">int</span> round)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= round; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">29</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">39</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                    map[j - <span class="number">1</span>][k].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                    map[j][k - <span class="number">1</span>].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= <span class="number">29</span>)</span><br><span class="line">                    map[j + <span class="number">1</span>][k].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (k + <span class="number">1</span> &lt;= <span class="number">39</span>)</span><br><span class="line">                    map[j][k + <span class="number">1</span>].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用是：将具有食物的位置的“食物价值”按照一定的衰减比例散布到周围四个位置，当我们进行了若干轮这样的传播以后，如果将食物的分值视为高度，整个地图的纵直方向的形状就类似于山地分布——我们的蛇只要向山地中的较高处运动，就能够保证兼具食物价值判断和追逐食物两个效果。</p><p>经过实践调整参数，食物价值传播的轮次设置为 $5$，食物价值传播的价值衰减率设置为 $0.57$</p><h2 id="大区域和小区域的权衡"><a href="#大区域和小区域的权衡" class="headerlink" title="大区域和小区域的权衡"></a>大区域和小区域的权衡</h2><p>在衡量一个位置的价值时，尽管有上述的食物价值图传播操作，但是传播的数量毕竟只有几轮，没办法普及到整个地图的所有位置，因此蛇的方向选择能然有可能只在局部上看来是较优的，但是从全局看来，蛇并没有主动地去移动到资源丰富的地区。所以，一个比较好的方法是同时衡量大区域的移动收益和小区域的移动收益选出最佳的移动方向。</p><p>对于大区域的移动收益，我主要采用区域价值密度作为衡量标准进行量化，考虑的标准有：</p><ul><li>区域的显示价值：所有食物和道具的价值总和</li><li>区域的隐式价值：当有蛇处在这个区域中，杀死它可以获得丰富的收益，这种收益被称为区域的隐式价值</li><li>区域的距离：一个区域距离自己越远，它的价值就相应地降低</li><li>区域的风险：其它蛇和障碍物会给一个区域带来风险——区域的风险对于区域价值而言是负增长的</li></ul><p>将这些因素乘以它们相应的权重，就能够得到一个区域的总价值，在程序中，这个总价值被称为 <code>largeZoneEvaluation</code> ，相应地，一个节点对应的近距离价值收益被称为 <code>closeZoneEvaluation</code>，<code>largeZoneEvaluation</code> 和 <code>closeZoneEvaluation</code> 乘以各自的权重，最终组成一个点的价值总和，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个点的利益（最终决策函数）</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">getPosValue</span><span class="params">(Pos position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 求出这一点的宏观收益 largeZoneValue</span></span><br><span class="line">    <span class="comment">// 思路：判断这一点的位置和自己的当前位置相比是否距离最富裕区域更近</span></span><br><span class="line">    Pos direc = &#123;position.row - me.bodies.<span class="built_in">front</span>().row, position.col - me.bodies.<span class="built_in">front</span>().col&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> largeZoneValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (direc.row &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(down, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.row &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(up, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.col &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(right, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.col &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(left, position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出这一点的纯粹价值收益 pureValue</span></span><br><span class="line">    <span class="comment">// 思路：bfs 图传播</span></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> closeZoneValue = <span class="built_in">closeZoneEvaluation</span>(position, SearchDepth);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> temp_Large_Zone_Weight = Large_Zone_Weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp_Large_Zone_Weight * largeZoneValue / Large_Zone_Evaluation_Standard + Close_Zone_Weight * closeZoneValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当参数调整得当时，理想的效果应该是，蛇会以资源丰富地区为大方向，并且向这个大方向不断靠近，过程中会主动选择吃掉得分较高的食物，实现快速发育的目标。</p><h2 id="策略计算和选择"><a href="#策略计算和选择" class="headerlink" title="策略计算和选择"></a>策略计算和选择</h2><p>本程序中，在决定向上下左右移动或是使用盾牌/障碍物前，会先经过一个策略选择的流程——</p><p>我为贪吃蛇程序确定了四种策略，它们分别是</p><ul><li>发育策略</li><li>逃跑策略</li><li>攻击策略</li><li>防御策略</li></ul><p>进行策略选择有以下这些流程：</p><ul><li>第一步：判断自己当前是否处在危险当中</li></ul><blockquote><p>主要通过判断区域的风险程度，并且设置一个“危险阈值”参数，当超过这个参数时，就会认定这片区域是存在风险的。这个参数越大，蛇的表现就会越“大胆”</p></blockquote><ul><li>第二步：计算贪心路径和逃跑路径的收益总和</li></ul><blockquote><p>进行深度为 $5$ 的搜索，计算出贪心路径和逃跑路径的总收益</p><p>逃跑路径指的是将风险权重设为 $0.7$，节点价值总和权重设置为 $0.3$，基于这两个参数计算出整条逃跑路径的价值总和</p><p>贪心路径指的是将风险权重设置为 $0.3$，节点价值总和权重设置为 $0.3$，基于这两个参数计算出整条贪心路径的价值总和</p><p>在第一步中，如果判断为非危险，就不可能采取逃跑路径，如果判定为危险，就会选择贪心路径或逃跑路径，此时需要对它们进一步判断</p><p>设置一个贪心阈值，如果两条路径的价值差超过了贪心阈值，就会采取贪心路径，否则认为不值得冒险，采取逃跑路径。贪心阈值越大，蛇的表现就会越“贪心”</p></blockquote><ul><li>第三步：计算当前是否值得采取攻击策略或是防御策略</li></ul><blockquote><p>当第一步中判断此时处在危险当中时，就会决定是否采取两个特殊策略</p><p>这两个特殊策略都是经过特判决定是否采取，特判的标准有：被攻击蛇的价值，附近蛇的数量，时间……</p></blockquote><ul><li>第四步：根据以上得到的数据选择一个策略</li></ul><p>事实上，以上操作的主要算法思想还是贪心：关键在于如何对贪心进行改善，使得不易陷入局部最优解并且通过对风险进行估值，使决策的结果考虑了一定“对抗”的因素</p><h1 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h1><h2 id="参数管理和优化"><a href="#参数管理和优化" class="headerlink" title="参数管理和优化"></a>参数管理和优化</h2><p>这点缺陷在贪吃蛇项目中显得尤为明显——总共设置的参数多达二十多个，这种情况下，参数管理显得尤为艰难，很多函数/功能在最后比赛时其实反到没有发挥它们的效果</p><p>在程序设计时，尽管设计每个参数都有考虑这些参数包含的涵义，但是当参数数量多时，很容易出现数据崩坏——一些参数的标准值一旦无法确定，就会增加很大的不确定性，那么，二十多个参数的组合很快就会成为一组混沌而无法预测的参数系统。</p><p>直到最后，调节参数很大程度基于直觉，这就让模型失去原有的意义，所以，参数的个数并不越多越好，并且尽量应该在设定一个参数后及时测量它们的标准，防止出现数据过于膨胀导致的问题。</p><h2 id="模型构建和实现步骤"><a href="#模型构建和实现步骤" class="headerlink" title="模型构建和实现步骤"></a>模型构建和实现步骤</h2><p>本次集训中发现的另一个问题是：在模型的构建过程总是期待一举建成完善和全面的模型，而调 <code>BUG</code> 的时间往往达到构建模型时间的两倍以上，事实上这是并不合理的一种开发方式——</p><p>以贪吃蛇为例，这个游戏的两个难点应该是各种棋形的判断和<code>Alpha-Beta</code> 剪枝函数的设计。我的做法是一次性地写好各种棋形的判断和 <code>Alpha-Beta</code> 剪枝函数，但是最后调 <code>BUG</code> 时发现了问题只好在整个程序中一步步搜寻。</p><p>但是，倘若在设计完棋形判断的函数后，并不马上进行 <code>Alpha-Beta</code> 剪枝函数的设计，而是先写一个根据每一点分值高低进行下棋的贪心算法程序。运行后根据下棋的效果很容易就能发现自己漏判断了什么棋形（或者哪种棋形判断出错），将棋形判断函数修改完善以后，再进行 <code>Alpha-Beta</code> 剪枝函数的设计，后续如果又出现问题，那么就在 <code>Alpha-Beta</code> 剪枝函数中寻找 <code>BUG</code> ，这样降低了代码检查的范围。</p><p>所以，很重要的一点教训就是——罗马非一日建成。复杂是简单的叠加，即使一开始就构思出非常复杂的模型时，也应该思考如何将这些复杂程序分解成小的步骤，如何在这些小的步骤中插入检测点，使得能够在逐步完成大作业最终任务的同时保证其正确性。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINGO 语言入门指南</title>
      <link href="/2022/08/21/LINGO%E6%8C%87%E5%8D%97/"/>
      <url>/2022/08/21/LINGO%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）为什么是-LINGO"><a href="#（一）为什么是-LINGO" class="headerlink" title="（一）为什么是 LINGO"></a>（一）为什么是 LINGO</h1><p><code>LINGO</code> 是一款专门用于解决规划类问题的软件。在处理线性规划问题上，和 <code>MATLAB</code> 相比，<code>LINGO</code> 更具有优势：</p><ul><li>可以支持二维决策变量</li><li>求解 <code>NLP</code> 问题时不需要进行初值估计</li><li>使用集合命令，更加直观，方便描述复杂条件</li><li>不需要人为指定算法，减少了理解算法的过程</li></ul><p>对于 <code>LINGO</code> 软件的使用，可以分为以下两种方法——</p><ul><li>直接描述法：用数学语言直接描述出线性规划模型的约束条件、决策变量和目标函数</li><li>建模描述法：通过用 <code>LINGO</code> 编程语言描述线性规划模型的变量和条件，实现模型的求解</li></ul><h1 id="（二）LINGO-直接描述法"><a href="#（二）LINGO-直接描述法" class="headerlink" title="（二）LINGO 直接描述法"></a>（二）LINGO 直接描述法</h1><p>直接描述法几乎没有难度——就是把数学问题几乎原样地在 <code>LINGO</code> 编程区描述一下，比如下面的代码就能直接在 <code>LINGO</code> 上运行，即使不需要注释也能很轻松地看懂.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max = 4 * x + 3 * y;</span><br><span class="line">2 * x + 3 * y &lt;= 10;</span><br><span class="line">x &gt;= 1;</span><br></pre></td></tr></table></figure><blockquote><p>在默认情况下，<code>LINGO</code> 会指定决策变量的取值都是大于 $0$ 的，解除这个限制需要使用 <code>@free</code> 函数</p><p>和 <code>MATLAB</code> 不同，<code>LINGO</code> 可以通过关键字 <code>max</code> 或 <code>min</code> 来指定目标函数是取最大/最小值</p><p>如果不指明关键字 <code>max</code> 或 <code>min</code> 比如将第一行代码修改为： <code>a = 4 * x + 3 * y</code></p><p>返回的提示就不再是 <code>Global optimal solution found.</code> ，而是 <code>Feasible solution found</code> ，表示找到可行解。</p></blockquote><p>运行结果如下，<code>LINGO</code> 会返回一个窗口，然后再窗口中详细描述本次规划问题解决的信息</p><center><img src = https://s1.ax1x.com/2022/08/21/vyy9RH.png width = 65%></center><blockquote><p>一般而言，简单的线性规划模型我们都会采用 <code>LINGO</code> 的直接描述法而不必进行建模描述</p></blockquote><h1 id="（三）LINGO-数据组织"><a href="#（三）LINGO-数据组织" class="headerlink" title="（三）LINGO 数据组织"></a>（三）LINGO 数据组织</h1><h2 id="LINGO-数据类型——集"><a href="#LINGO-数据类型——集" class="headerlink" title="LINGO 数据类型——集"></a>LINGO 数据类型——集</h2><p><code>LINGO</code> 的集定义为：一群相联系的对象。事实上，“集”就是一个由对象组成的群体。</p><p><code>LINGO</code> 的集分为两种类型——</p><ul><li>原始集：只由对象组成</li><li>派生集：可以由原始集组成，也可以包含其它派生集</li></ul><p>集合的定义：</p><p>我们直接从一个现实实例来具体说明如何定义 <code>LINGO</code> 集合类型：</p><p><code>LINGO</code> 中的所有集合变量必须定义在一个框架中：框架的开头是 <code>sets:</code> ，框架的末尾是 <code>endsets</code> ，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sets:</span><br><span class="line">    !这是一个可以跨越多行的注释（用 &#x27;!&#x27; 开头，用 &#x27;;&#x27; 结尾）</span><br><span class="line">    set1</span><br><span class="line">    set2</span><br><span class="line">    ......</span><br><span class="line">    set3</span><br><span class="line">    ;</span><br><span class="line">endsets</span><br></pre></td></tr></table></figure><p>假设我们要将一个学生群体定义成 <code>LINGO</code> 集合数据的形式。</p><p>我们可以单纯地只定义一个学生群体的集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student;</span><br></pre></td></tr></table></figure><p>我们也可以为这个学生集合添加属性变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student: name, age; </span><br></pre></td></tr></table></figure><p>这行代码的语法表示：我们定义学生群体，这个对象有性别和年龄两个属性变量</p><p>而当我们要阐释一个群体中所有成员时，则可以采用下面的语法（显示罗列法）逐个罗列出对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student/stu1, stu2, stu3/: name, age;</span><br></pre></td></tr></table></figure><p>这行代码表示学生集合中有三个对象：他们分别是<code>stu1</code>，<code>stu2</code> 和 <code>stu3</code></p><p>而当我们要定义更多的集合对象时，很明显我们不能一个一个的输入对象们的名字——当数据量一大，这实在是不小的工程量。幸运的是 <code>LINGO</code> 提供了隐式罗列法：这也是 <code>LINGO</code> 的特别之处，它定义了 <code>..</code> 运算符，这个运算符可以智能地根据规律来填充我们没有完全写出的集合对象名，我们可以像下面这样使用它——</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student/stu1..stu100/: name, age;</span><br></pre></td></tr></table></figure><p>这行代码表示学生集合中一共有 $100$ 个学生对象，它们的对象名分别是 <code>stu1</code> ，<code>stu2</code>，$\cdots$ ，<code>stu100</code></p><blockquote><p><code>LINGO</code> 大小写不敏感——这意味着 <code>STU1</code> 和 <code>stu1</code> 代表完全相同的涵义</p><p><code>LINGO</code> 规定在集合数据类型的定义中只有集合名字是必须声明的，而集合的成员列表和属性变量列表都是可以省略的</p></blockquote><p>另外我们还可以通过已有的集合来定义新的集合，这就是派生集的定义。</p><p>考虑工厂加工问题的求解：我们需要定义不同工人操作不同机器，他们加工不同产品，那么可行方案就应该是：哪个工人 + 操作哪台机器 + 生产哪个产品，定义方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sets:</span><br><span class="line">! 原始集;</span><br><span class="line">worker:/worker1..worker3/: efficiency;    ! 工人效率;</span><br><span class="line">machine:/machine1..machine3/: quality;    ! 机器质量;</span><br><span class="line">product:/product1..product3/: value, cost; ! 产品价值和消耗;</span><br><span class="line"></span><br><span class="line">! 派生集;</span><br><span class="line">allowed_plan(worker, machine, product): evaluation;    ! 对可行方案的评价;</span><br><span class="line">endsets</span><br></pre></td></tr></table></figure><p>像上面这样，派生集的所有对象实际上就是原始集的所有对象的组合，即 $(workeri,machinej, productk)\; ,i\in(1,3),\; j\in(1,3),\; k\in(1,3)$ ，这种派生集就称为<strong>稠密集</strong></p><p>相反，如果原始集的所有对象的组合并不包含在派生集中，那么这种派生就被称之为<strong>稀疏集</strong></p><p>此外，我们经常看到 <code>links</code> 相关的语法，事实上它们的本质也是派生集，只是 <code>links</code> 显示地指出这些集是派生出来</p><blockquote><p>也有人用“矩阵工厂”的概念来描述集合，我赞同他们的观点</p></blockquote><h1 id="（四）LINGO-集合初始化"><a href="#（四）LINGO-集合初始化" class="headerlink" title="（四）LINGO 集合初始化"></a>（四）LINGO 集合初始化</h1><p>在定义了“集合”这种数据类型之后，我们就可以对这些集合数据类型进行初始化赋值</p><p><code>LINGO</code> 的集合初始化也是需要定义在一定的框架内，这个框架的形式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">   !将数据定义在这里面;</span><br><span class="line">enddata</span><br></pre></td></tr></table></figure><p>我们对集合数据类型进行初始化赋值，本质上是对属于集合的所有成员对象的属性变量进行赋值，还是通过上面那个工人借助机器生产产品的例子，我们对这个例子中的数据进行赋值——</p><h2 id="对集合对象的所有属性变量进行初始化"><a href="#对集合对象的所有属性变量进行初始化" class="headerlink" title="对集合对象的所有属性变量进行初始化"></a>对集合对象的所有属性变量进行初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">efficiency = 4 3 2</span><br><span class="line">quality = 3 2 1</span><br><span class="line">value = 50 20 10</span><br><span class="line">enddata</span><br></pre></td></tr></table></figure><p>像上面这样，我们可以通过每行对一个变量进行赋值，Lingo语言会帮我们将这些空格隔开的数字按照顺序相应的赋值给集合的成员对象</p><p>比如 <code>efficiency</code> 那一行中 <code>=</code> 后的 $3$ 个数字分别意味着 <code>worker1</code> 的效率是 $4$ ，<code>worker2</code> 的效率是 $3$ ，<code>worker3</code> 的效率是 $2$ ，剩下两行的内容同理可得</p><p>当然对于那些对象个数一样的属性变量我们可以将它们放在一行中一起赋值，这个时候数据的组织顺序有所不同，比如我们可以将上面 $3$ 个属性变量（因为它们的对象个数都是 $3$ 个）放在一行中，然后将要输入的数据组织成矩阵进行赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">efficiency, quality, value = 4 3 50</span><br><span class="line">                             3 2 20</span><br><span class="line">                             2 1 10;</span><br><span class="line">enddata</span><br></pre></td></tr></table></figure><blockquote><p><code>LINGO</code> 通过换行隔离开不同个数据</p></blockquote><p>在上面这个 $3\times3$ 的矩阵中，第一列代表了工人的效率，第二列代表机器的品质，第三列则代表产品的价值</p><p>这样我们的数据类型描述就算完成了。当然你可能会疑问：那些只能被规定为整数变量的数据类型应该怎么描述呢？这就涉及到 <code>LINGO</code> 函数的使用，紧接着将会解释这一部分内容。</p><h2 id="其他特殊的数据初始化方式"><a href="#其他特殊的数据初始化方式" class="headerlink" title="其他特殊的数据初始化方式"></a>其他特殊的数据初始化方式</h2><ul><li>在所有集合对象中将一个属性变量初始化为同一个值</li></ul><p>比如我们设置所有工人的效率一样，都为 $3$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efficiency = 3;</span><br></pre></td></tr></table></figure><ul><li>实时数据处理</li></ul><p>比如我们设置 <code>worker2</code> 的效率为非定值，只要在本该放书的地方输入一个 <code>?</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efficiency = 2 ? 4;</span><br></pre></td></tr></table></figure><ul><li>未知数值处理</li></ul><p>我们希望在程序模型中将一个属性变量在部分成员对象中设置为未知，以便让 <code>LINGO</code> 求出它们的最优解</p><p>在属性变量的某些值为未知的时候，我们不能再用空格隔开不同的值，而应该用逗号来取代，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efficiency = 2, , ;</span><br></pre></td></tr></table></figure><p>这里表示 <code>worker2</code> 和 <code>worker3</code> 的 <code>efficiency</code> 都是未知的</p><h1 id="（五）LINGO-运算符"><a href="#（五）LINGO-运算符" class="headerlink" title="（五）LINGO 运算符"></a>（五）LINGO 运算符</h1><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>当我们需要使用 <code>LINGO</code> 来描述一个线性规划问题时，很自然的就需要使用逻辑运算符来描述问题应该满足的条件</p><p><code>LINGO</code> 提供了 $9$ 种逻辑运算符，如下表所示：</p><div class="table-container"><table><thead><tr><th>运算符名称</th><th>运算符涵义</th></tr></thead><tbody><tr><td>#not#</td><td>一元运算符，否定该操作数的逻辑值</td></tr><tr><td>#eq#</td><td>若两个运算数相等，则为 true ，否则为 false</td></tr><tr><td>#gt#</td><td>若左边的运算符严格大于右边的运算符，则为 true ，否则为 false</td></tr><tr><td>#ge#</td><td>若左边的运算符大于或等于右边的运算符，则为 true ，否则为 false</td></tr><tr><td>#lt#</td><td>若左边的运算符严格小于右边的运算符，则为 true ，否则为 false</td></tr><tr><td>#le#</td><td>若左边的运算符小于或等于右边的运算符，则为true，否则为false</td></tr><tr><td>#and#</td><td>仅当两个参数都为true时，结果为true，否则为false</td></tr><tr><td>#or#</td><td>仅当两个参数都为false时，结果为false，否则为true</td></tr></tbody></table></div><h2 id="算术运算符和关系运算符"><a href="#算术运算符和关系运算符" class="headerlink" title="算术运算符和关系运算符"></a>算术运算符和关系运算符</h2><p><code>LINGO</code> 提供了 $5$ 种二元运算符，优先级和我们平常认知的相同</p><p>即 <code>^</code>、<code>*</code>、<code>/</code>、<code>+</code> 和 <code>-</code> 。</p><p>一元运算符只有取反：<code>-</code></p><p><code>LINGO</code> 关系运算符主要用于描述约束条件，它们和逻辑运算符并不相同，不存在真假，只要是被关系运算符所描述的，就是在我们的模型中所有决策变量必须遵守的条件。</p><p>提供了 $3$ 种关系运算符，即 <code>=</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 。但 <code>LINGO</code> 并不支持严格小于和严格大于的关系算符，不过我们可以通过修改小于等于式来实现这种关系：</p><p>如 $a&gt;b$ 可以修改为 $a+\epsilon&gt;=b$，$\epsilon$ 是一个很小的正数，它的取值取决于于我们模型中所需要的精度。</p><h1 id="（六）LINGO函数"><a href="#（六）LINGO函数" class="headerlink" title="（六）LINGO函数"></a>（六）LINGO函数</h1><p><code>LINGO</code> 的函数特点是：每个函数都在开头位置有一个 <code>@</code> 符表示这是一个函数。</p><p><code>LINGO</code> 的函数有如下几种分类——</p><h2 id="变量界定函数"><a href="#变量界定函数" class="headerlink" title="变量界定函数"></a>变量界定函数</h2><p>变量界定函数实现对决策变量取值范围的附加限制：</p><ul><li><code>@bin(x)</code> 限制 $x$ 为 $0$ 或 $1$</li><li><code>@bnd(L, x, U)</code> 限制 $L\le x\le U$</li><li><code>@free(x)</code> 取消对变量 $x$ 的默认下界为 $0$ 的限制，即 $x$ 可以取任意实数</li><li><code>@gin(x)</code> 限制 $x$ 为整数</li></ul><blockquote><p>在默认情况下，<code>LINGO</code> 规定变量是非负的，也就是说下界为 $0$，上界为 $+\infin$。<code>@free</code> 取消了默认的下界为 $0$ 的限制，使变量也可以取负值。<code>@bnd</code> 用于设定一个变量的上下界,它也可<br>以取消默认下界为 $0$ 的约束。</p></blockquote><h2 id="集循环函数"><a href="#集循环函数" class="headerlink" title="集循环函数"></a>集循环函数</h2><p>集循环函数通过遍历属性变量所在的整个集的所有对象来进行操作：</p><p>集循环函数的语法是：<code>@for(集合名(i): [对属性名(i)的相关操作])</code></p><p>上面的语法看起来很抽象我们还是通过上面的例子来解释一下这个语法——</p><p>假设我们希望对工人的效率进行赋值，使得工人的效率满足：$工人的效率 = 工人的索引 \times 2 + 1$，可以使用下面的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@for(worker(i): efficiency(i) = 2 * i + 1);</span><br></pre></td></tr></table></figure><p>如果我们只想操作 <code>worker1</code> 和 <code>worker2</code> 也可以通过 <code>|</code> 后添加范围的语法调用：</p><blockquote><p>操作范围是一个逻辑表达式，当这个逻辑表达式为真时就会对 <code>:</code> 后面的相应索引的属性变量进行相应操作。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@for(worker(i) | i #le# 2 : efficiency(i) = 2 * i + 1);</span><br></pre></td></tr></table></figure><p><code>@sum</code> 函数、 <code>@min</code> 函数、 <code>@max</code> 函数和 <code>prog</code>函数（求积）的语法都非常类似，它们也可以添加函数操作范围，并用竖线 <code>|</code> 分隔属性名和操作范围。</p><p>如下的代码用来计算 $3$ 个工人的效率总和以及前 $2$ 个工人的效率最大值和最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">efficiency_sum = @sum(worker(i) | i #le# 3 : efficiency);</span><br><span class="line">efficiency_min = @min(worker(i) | i #le# 2 : efficiency);</span><br><span class="line">efficiency_max = @max(worker(i) | i #le# 2 : efficiency);</span><br></pre></td></tr></table></figure><p>我们详细解释一下第二行代码的意思吧：他表示对 <code>worker</code> 中的 <code>efficiency</code> 属性求解最小值并且索引 <code>i</code> 小于等于 $2$，这意味着他在进行这个函数的时候只会考虑前 $2$ 个对象的 <code>efficiency</code> 属性</p><p>当然我们也可以不指定范围这样就默认对集合中所有成员对象的某个属性变量进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">efficiency_sum = @sum(worker : efficiency);</span><br><span class="line">efficiency_min = @min(worker : efficiency);</span><br><span class="line">efficiency_max = @max(worker : efficiency);</span><br></pre></td></tr></table></figure><p>上面三行代码表示求解所有工人效率的总和、最小值和最大值。</p><blockquote><p>这些集循环函数的调用其实都很相似，只是 <code>@for</code> 函数需要指定操作方式，其它四种只需要指定操作的属性，仅此而已</p><p>可以统一成这种格式：<code>@函数名(集合名(索引) | 范围界定（可选） : 要操作的属性变量或要进行的操作)</code></p><p>很经常地，这些集合操作函数不只是对集合进行操作，往往还用来描述目标函数和约束条件，可以到最后的例题中体会实际使用的方法</p><p>可以让要操作的属性可以不属于集合名，而只是把集合名当作提供索引的“工具人”，如后面例题中的 $TSP$ 问题描述每行/每列之和为 $1$ 时的处理</p></blockquote><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>数学函数是 <code>LINGO</code> 语言中几乎最重要的函数。因为我们刚刚说过 <code>LINGO</code> 只支持 $5$ 种最基本的运算符号，而要实现复杂的函数就必须调用数学函数。</p><p>数学函数都是顾名思义就能理解，可以参见下面这张表格：</p><center><img src = https://s1.ax1x.com/2022/08/21/vysxIO.png width = 40%></center><h2 id="逻辑判断函数"><a href="#逻辑判断函数" class="headerlink" title="逻辑判断函数"></a>逻辑判断函数</h2><p><code>@if</code> 函数是一个逻辑判断函数，通常仅仅在分段函数处出现，一般其出现频率、使用次数不高。</p><p>函数调用形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@if(条件描述, 满足条件的返回值, 不满足条件的返回值)</span><br></pre></td></tr></table></figure><p>比如我们希望定义一个分段函数，在小于等于零时返回 $0$ ，在大于零时返回原值，就可以用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@if(x #le# 0, 0, x);</span><br></pre></td></tr></table></figure><p>我们还可以为逻辑判断函数设置嵌套，比如我们希望在小于等于 $-2$ 时返回 $x^2$ 而不是 $0$，就可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@if(x #le# 0, @if(x #le# -2, x^2, 0), x);</span><br></pre></td></tr></table></figure><p>这行代码在满足条件的返回值处内嵌了一个 <code>@if</code> 函数</p><h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><h3 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h3><p>一些输入输出函数可以用来帮助我们节约从文件转移数据的时间。</p><ul><li><code>@file(&#39;filename&#39;);</code> ： 从外部文件输入数据</li><li><code>@text(&#39;filename&#39;);</code> ： 将指定内容输出到文本文件中</li><li><code>@ole(&#39;filename&#39;)</code> ： 从 <code>EXCEL</code> 中引入或输出数据</li><li><code>@warn(&#39;text&#39;, logical_condition)</code> ： 如果逻辑条件 <code>logical_condition</code> 为真，则产生一个内容为<code>&#39;text&#39;</code> 的信息框。</li></ul><h3 id="返回信息函数"><a href="#返回信息函数" class="headerlink" title="返回信息函数"></a>返回信息函数</h3><p>一些函数返回信息函数能返回模型中求解的情况</p><ul><li><code>@status()</code> ： 返回 LINGO 求解模型结束后的状态：是否可行，全局/局部最优</li><li><code>@dual(variable_name)</code> ： 返回变量的判别数的影子值</li></ul><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p><code>@rand(seed)</code> ： 返回 $0$ 和 $1$ 间的伪随机数，依赖于指定的种子。</p><blockquote><p>一下子记忆太多内容是痛苦的，这些函数留到需要使用时再查阅具体资料即可（但是知道它们的存在倒是一件重要的事）</p><p>概率函数和金融函数不包含在以上函数中，读者可以在需要使用时自行检索。</p></blockquote><h1 id="（七）LINGO-模型描述"><a href="#（七）LINGO-模型描述" class="headerlink" title="（七）LINGO 模型描述"></a>（七）LINGO 模型描述</h1><p>我们直接用两个具体的例子来讲解 <code>LINGO</code> 的模型描述法如何处理规划类问题</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 $1$"></a>例题 $1$</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><center><img src = https://s1.ax1x.com/2022/08/21/vyypJe.png width = 60%></center><h3 id="代码和注释"><a href="#代码和注释" class="headerlink" title="代码和注释"></a>代码和注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">model: ! 模型应写在 model 和 end 间的框架中 ;</span><br><span class="line"></span><br><span class="line">sets: ! 集合数据类型定义 ;</span><br><span class="line"></span><br><span class="line">! 定义 6 个仓库以及它们的容量属性 ;</span><br><span class="line">warehouse/w1..w6/: capacity; </span><br><span class="line"></span><br><span class="line">! 定义 8 个客户以及他们的订单量属性 ;</span><br><span class="line">client/c1..c8/: requirements; </span><br><span class="line"></span><br><span class="line">! 派生上面集合，links 集合的元素是上面两个集合的两两组合，这些元素有一个属性 freight ，相当于 freight(i, j) 为从仓库 i 运输给客户 j 所需要的运费 ;</span><br><span class="line">! 同理 plan(i, j) 表示我们计划从仓库 i 运输给客户 j 的货运量，它就是本题的决策变量;</span><br><span class="line">links(warehouse, client): freight, plan;</span><br><span class="line"></span><br><span class="line">endsets</span><br><span class="line"></span><br><span class="line">data: ! 集合数据类型赋值 ;</span><br><span class="line"></span><br><span class="line">capacity = 60, 55, 51, 43, 41, 52;</span><br><span class="line">requirements = 35, 37, 22, 32, 41, 32, 43, 38;</span><br><span class="line">freight = 6, 2, 6, 7, 4, 2, 5, 9</span><br><span class="line">          4, 9, 5, 3, 8, 5, 8, 2</span><br><span class="line">          5, 2, 1, 9, 7, 4, 3, 3</span><br><span class="line">          7, 6, 7, 3, 9, 2, 7, 1</span><br><span class="line">          2, 3, 9, 5, 7, 2, 6, 5</span><br><span class="line">          5, 5, 2, 2, 8, 1, 4, 3;</span><br><span class="line">enddata</span><br><span class="line"></span><br><span class="line">! 目标函数是求解总运费的最小值 ;</span><br><span class="line">min = @sum(links(i, j) : freight(i, j) * x(i, j)); </span><br><span class="line"></span><br><span class="line">! 约束条件1：一个仓库运出的最大货物不应该超过仓库中的所有货物;</span><br><span class="line">@for(warehouse(i) : @sum(client(j) : plan(i, j)) &lt;= capacity(i));</span><br><span class="line"></span><br><span class="line">! 约束条件2：应该刚好满足客户的订单量;</span><br><span class="line">@for(client(j) : @sum(warehouse(i) : plan(i, j)) = requirement(j));</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 $2$"></a>例题 $2$</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>旅行商问题（$TSP\ Problem$）</p><p>假设有 $9$ 个城市，它们之间两两距离为：</p><center><img src = https://s1.ax1x.com/2022/08/21/vyySiD.png width = 70%></center><p>现在我们需要为旅行商设计一条路线，使得他可以经过所有的 $9$ 个城市（每个城市只经过一次），并且最终行走的总距离最少。</p><h3 id="代码和注释-1"><a href="#代码和注释-1" class="headerlink" title="代码和注释"></a>代码和注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">model:</span><br><span class="line"></span><br><span class="line">sets:</span><br><span class="line"></span><br><span class="line">! 定义一段路的起始城市和终点城市 ;</span><br><span class="line">cities/city1..city9/: city;</span><br><span class="line"></span><br><span class="line">! 定义两两城市之间的距离和路线 ;</span><br><span class="line">! dist(i, j) 表示城市 i 和 j;</span><br><span class="line">! route(i, j) = 1 表示环路中存在从城市 i 前往城市 j 这条路径，0 表示不存在 ;</span><br><span class="line">links(cities, cities): dist, route;</span><br><span class="line"></span><br><span class="line">endsets</span><br><span class="line"></span><br><span class="line">data:</span><br><span class="line"></span><br><span class="line">! 数据主要是需要传入两两城市之间的距离 ;</span><br><span class="line">dist = 0, 200, 660, 170, 127, 225, 490, 420, 330                            </span><br><span class="line">       200, 0, 820, 300, 90, 60, 310, 225, 151                        </span><br><span class="line">       660, 820, 0, 530, 770, 120, 1110, 1050, 960                    </span><br><span class="line">       170, 300, 530, 0, 280, 350, 600, 550, 450                </span><br><span class="line">       127, 90, 770, 280, 0, 110, 370, 310, 210            </span><br><span class="line">       225, 60, 120, 350, 110, 0, 280, 250, 120        </span><br><span class="line">       490, 310, 1110, 600, 370, 280, 0, 290, 190    </span><br><span class="line">       420, 225, 1050, 550, 310, 250, 290, 0, 160</span><br><span class="line">       330, 151, 960, 450, 210, 120, 190, 160, 0 ;</span><br><span class="line"></span><br><span class="line">enddata</span><br><span class="line"></span><br><span class="line">n = @size(cities);</span><br><span class="line"></span><br><span class="line">! 目标函数：求总路径的最小值 ;</span><br><span class="line">! 只有在 route(i, j) 不为 0 时表示这条路径存在，乘以 dist(i, j) 代表计入相应的路径长度 ;</span><br><span class="line">min = @sum(links(i, j) : dist(i, j) * route(i, j));</span><br><span class="line"></span><br><span class="line">! 变量定界：0-1 规划问题 ;</span><br><span class="line">@for(links(i, j) : @bin(route(i, j)));</span><br><span class="line"></span><br><span class="line">! 每个城市必须到过一次，即路线矩阵: </span><br><span class="line">    - 每一行的和为 1 </span><br><span class="line">    - 每一列的和也为 1 ;</span><br><span class="line"></span><br><span class="line">! 每一行的和为 1 ;</span><br><span class="line">@for(cities(j) : @sum(cities(i) : route(i,j)) = 1); ! 这里的 cities 就是一个“工具人” ，我们操作的属性并不属于这个集合，只是用它来提供索引 ;</span><br><span class="line"></span><br><span class="line">! 每一列的和为 1 ;</span><br><span class="line">@for(cities(i) : @sum(cities(j) : route(i,j)) = 1);</span><br><span class="line"></span><br><span class="line">! 确保没有子圈（city(i) 和 city(j) 实际上没有赋值，并不具有真实涵义，用来当作辅助值） ;</span><br><span class="line">@for(links(i, j) | i #ne# j #and# i #gt# 1 : city(i) - city(j) + n * route(i, j) &lt;= n - 1);</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="（八）写在后面"><a href="#（八）写在后面" class="headerlink" title="（八）写在后面"></a>（八）写在后面</h1><p><code>LINGO</code> 一直以来就以内置建模语言和优秀的建模算法著称，不少人将 <code>LINGO</code> 作为优化模型求解的不二选择，但是 <code>LINGO</code> 真的就能解决所有的优化问题吗？</p><p>很显然答案是否定的—— <code>LINGO</code> 的优势在于求解非线性规划时比较方便，只需要使用编程语言描述模型，系统就能自动地给出解。这使得使用者不必关心 <code>LINDO</code> 公司具体选择了什么算法来执行求解的过程，能将更多的心力放在模型的架构和完善上。</p><p>但是假如我们要训练一个参数规模巨大的神经网络，使用 <code>LINGO</code> 来进行参数优化求解往往就显得心有余而力不足——因为过程中消耗的时间是我们不得不考虑的因素，这时我们就应该去考虑执行效率更高的工具。</p><blockquote><p>同理对于 <code>matlab</code> 中提供的 <code>ga</code> 函数，</p></blockquote><p>学会扬长避短，根据具体情况选择合适的工具也是建模能力之一。</p><blockquote><p>参考资料：</p><p>数据输入部分：<a href="https://zhuanlan.zhihu.com/p/153127289">https://zhuanlan.zhihu.com/p/153127289</a></p><p>数学函数部分：<a href="https://www.jianshu.com/p/a39b411ec367">https://www.jianshu.com/p/a39b411ec367</a></p><p><code>LINGO</code> 建模例题：<a href="https://blog.csdn.net/Dai_sir_man/article/details/120064306">https://blog.csdn.net/Dai_sir_man/article/details/120064306</a> 和 <a href="https://blog.csdn.net/Xiao_CangTian/article/details/89506978">https://blog.csdn.net/Xiao_CangTian/article/details/89506978</a></p><p>其余部分：《<code>LINGO</code> 官方文档》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本遗传算法</title>
      <link href="/2022/08/21/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/21/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="启发式算法系列开篇"><a href="#启发式算法系列开篇" class="headerlink" title="启发式算法系列开篇"></a>启发式算法系列开篇</h1><p>这是介绍启发式算法家族的第一篇文章。</p><p>启发式算法指的是：</p><p>启发式算法主要区别于传统优化算法，后者通过目标函数的梯度达到目标函数结果最优化，它是一种确定性的搜索方式。</p><p>而启发式算法的特点就在于随机搜索并且通过这一特性获取更高的全局最优可能性。由于和函数梯度的利用无关，所以启发式算法并不要求目标函数具有连续可微的条件，为一些无法通过梯度下降优化的目标函数提供了优化的可能性。</p><p>人类通过观察自然的演变和动物的行为，将它们用于真实场景的模拟当中，这些就是启发式算法的灵感来源，因此这些算法听上去也比一般的算法更加有趣，无论是初入算法世界的萌新，还是准备数模竞赛的同学，都能在启发式算法的家族里窥探到算法学家的智慧和有趣。</p><p>本文同接下来一个系列的几篇文章都将介绍启发式算法的原理、具体过程到最后的代码实现，代码实现上，会提供尽量 <code>MATLAB</code> 和 <code>python</code> 两种代码框架。</p><p>欢迎关注 &amp; 追更！！！</p><h1 id="遗传算法基础"><a href="#遗传算法基础" class="headerlink" title="遗传算法基础"></a>遗传算法基础</h1><h2 id="遗传算法简介"><a href="#遗传算法简介" class="headerlink" title="遗传算法简介"></a>遗传算法简介</h2><p>遗传算法（Genetic Algorithm，简称 GA ），顾名思义，这是一种模拟自然选择生物进化和个体繁衍时交叉、复制、变异等现象的算法。</p><p>遗传算法的过程就模拟了一个物种的进化史诗，而其结果旨在于通过残酷的优胜劣汰机制留下我们规定的世界中的最优解——哪个种群越接近最优解，才能挺过无数场竞争，让基因得以保留。</p><h2 id="遗传算法术语和概念"><a href="#遗传算法术语和概念" class="headerlink" title="遗传算法术语和概念"></a>遗传算法术语和概念</h2><h3 id="染色体、位串、基因"><a href="#染色体、位串、基因" class="headerlink" title="染色体、位串、基因"></a>染色体、位串、基因</h3><p>位串在算法中就相当于生物学上的染色体的概念。</p><p>而基因则可以看作染色体的组成单元，染色体上的所有基因共同作用，最终决定了一个个体的性状。</p><p>比如，在很多情况下，我们会将基因建模成一个个二进制位，则染色体就是一个二进制串。</p><p>举一个非常简单的例子，我们希望确定一组参数 $w_1,w_2,\cdots,w_n$ ，能够使目标问题得到最优解。</p><p>就取 $w_1,w_2,\cdots,w_n$ 的二进制数，将它们拼接成一个 $01$ 串，这个串上的每个 $0$ 或者 $1$，都是一个基因</p><p>而这组参数的取值就可以称之为一个染色体，比如我们认为 $w_1,w_2,\cdots,w_n$ 都是一个八位二进制数，它们就能表示为：</p><script type="math/tex; mode=display">\underbrace{10111010101010111\cdots0101001001001111\cdots010100111100101}_{共 8\times n位}</script><h3 id="特征值"><a href="#特征值" class="headerlink" title="特征值"></a>特征值</h3><p>在用串表示整数时，基因的特征值与二进制数的权一致——比如染色体 $10001$ 中第一个 $1$ 表示的基因的特征值为 $16$</p><h3 id="基因型和表现型"><a href="#基因型和表现型" class="headerlink" title="基因型和表现型"></a>基因型和表现型</h3><p>基因型在遗传算法中指的就是问题可行解的一种编码，比如上面举的那个例子中，$10111010101010111\cdots0101001001001111\cdots010100111100101$ 就是一个基因型，它经过解码后还原得到的一组参数 $w_1,w_2,\cdots w_n$ 在实际问题中的表现状态就是一组可行解的表现型。</p><blockquote><p>事实上，一组可行解就是一个个体</p></blockquote><h3 id="适应度"><a href="#适应度" class="headerlink" title="适应度"></a>适应度</h3><p>这是遗传算法中最重要的概念之一（<strong>敲黑板</strong>），因为——</p><p>它决定了我们规定的进化方向，是这个优胜劣汰的世界中的基本规则</p><p>适应度的本质就是一个函数，根据上面的例子，这个函数可能就像下面这样：</p><script type="math/tex; mode=display">X = t(w_1,w_2,\cdots,w_n)</script><script type="math/tex; mode=display">S = f(X)</script><p>这两行公式的意思是，函数 $t(w_1,w_2,\cdots,w_n)$ 表示一个生物个体的基因在目标函数下的表现性状。</p><blockquote><p>目标函数指的就是我们希望优化的对象</p><p>在自然界中，这个目标函数就是尽量地活下去</p><p>在我们的遗传算法空间中，这个目标函数就由我们自己定义：它可以指旅行商问题中的路径，可以指加工一批硬件的时间……</p></blockquote><p>生物的表现性状 $X$ 由它的一系列基因 $w_1,w_2\cdots,w_n$ 决定，$f(X)$ 就是适应度函数，适应度函数旨在于评估生物性状，给出哪些生物更适合活下来的依据。</p><p>对应到算法中，适应度函数就是我们优化的对象，比如让旅行商的行走总路径，那么遍历每个城市的任何一种方案都可以视为具有各自染色体的个体，我们的适应度设计目的就是为了寻找最优、最符合问题答案的个体的染色体，它就是我们问题的解。</p><h3 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h3><p>算子的英文原名就是 $operator$，其实就是操作，算子的种类有：</p><ul><li>选择算子（Selection Operator）</li><li>交叉算子（Crossover Operator）</li><li>变异算子（Mutation Operator）</li></ul><p>这三个算子的涵义和作用会在后面具体过程中进行讲解，注意：这只是基本遗传算法的算子，更复杂的遗传算法会包含更多种类的算子。</p><h1 id="遗传算法的步骤"><a href="#遗传算法的步骤" class="headerlink" title="遗传算法的步骤"></a>遗传算法的步骤</h1><h2 id="（一）染色体编码"><a href="#（一）染色体编码" class="headerlink" title="（一）染色体编码"></a>（一）染色体编码</h2><p>我们刚刚已经提到过，遗传算法的可行解可以表示成基因的形式，基因也可以被还原为可行解的形式。前者被称为编码，后者则称为解码。</p><blockquote><p>比如 $\underbrace{10111010101010111\cdots0101001001001111\cdots010100111100101}_{共 8\times n位}$ 就是基因，$w_1,w_2,\cdots w_n$ 就是一组可行解（性状）</p></blockquote><p>一般而言，染色体编码要遵循下面这些准则：</p><ul><li><p>完备性（Completeness）：问题空间中的所有候选解都能编码为 GA 空间中的染色体</p></li><li><p>非冗余性（Nonredundancy）：染色体和候选解一一对应</p></li></ul><p>下面提供三种染色体编码的技巧和思路：</p><h3 id="二进制编码方法"><a href="#二进制编码方法" class="headerlink" title="二进制编码方法"></a>二进制编码方法</h3><p>就是将一组问题的可行解全部转换为二进制数的形式，并对这些二进制数进行拼接得到一个 $01$ 串，这个 $01$ 串就是染色体</p><blockquote><p>注意：小数和整数都可以编码成二进制数。对于小数而言，还应该在编码时确定小数点的位置</p><p>编码方案应该和数据范围以及数据变化灵敏度相适应，如下：</p></blockquote><p>$000000\cdots00000 = 0\delta$ 对应范围的下界</p><p>$111111\cdots11111 = (2^n-1)\delta$ 对应范围的上界</p><p>而 $000000\cdots00001$ 表示数据的灵敏度 $\delta$</p><h3 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a>格雷编码</h3><p>格雷码（Grey Code）也被称之为反射二进制码，是一个二进制数系，其中两个相邻数的二进制位只有一位不同，并且最大数与最小数之间也仅一位数不同。</p><p>二进制码和格雷码在使用时的一点明显区别就是：</p><p>比如当一个染色体的取值需要增加一个单位量时（$\sigma$），如果原染色体是 $1000001111111$ ，转换后得到的就是 $100001000000$ ，一共需要修改 $7$ 个基因，而如果使用格雷码进行编码，“相邻染色体”之间的差别就是一个基因，大大降低了相邻值之间的转换时间，能够使算法的局部搜索能力增强。</p><p>格雷码和二进制码的相互转换可以使用下面的思路进行转换：</p><p>设某二进制格雷码为 $G_{n-1}G_{n-2}\cdots G_2G_1G_0$，自然二进制码为 $B_{n-1}B_{n-2}\cdots B_2B_1B_0$</p><p>二进制码转格雷码：</p><ul><li>最高位保留：$G_{n-1} = B_{n-1}$</li><li>其它各位进行异或操作：$G_i = B_{i+1}\oplus B_i$</li></ul><p>格雷码转二进制码：</p><ul><li>最高位保留：$B_{n-1}=G_{n-1}$</li><li>其它各位进行异或运算：$B_{i-1}=G_{i-1}\oplus B_i$</li></ul><blockquote><p>由于格雷码拥有二进制编码的优点，并且其特性更提供了一些额外的优势，因此建议在使用二进制时，总是用格雷码进行替代</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>返回结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="浮点数编码方法"><a href="#浮点数编码方法" class="headerlink" title="浮点数编码方法"></a>浮点数编码方法</h3><p>将一组问题的可行解全部转换为浮点数的形式，浮点数的设计可以参照 $IEEE$ 标准自行完成，目的是为了增大可行解的表示范围，又不至于让染色体变得过长</p><blockquote><p>一些精度要求较高的问题，如果使用二进制编码直接表示，往往会使得染色体的长度变得过长，不利于我们求解</p><p>使用浮点数进行编码不是为了能够表示小数（这点二进制编码也能够做到），而是为了能够利用阶码表示更大的数</p></blockquote><h3 id="符号编码方法"><a href="#符号编码方法" class="headerlink" title="符号编码方法"></a>符号编码方法</h3><p>使用自定义的符号进行编码的方法，其中自定义的符号是指无数值含义、而只有代码含义的符号集，比如 $\{solution_1,solution_2,\cdots,solution_n\}$</p><p>应该注意的是，使用符号编码后，还要考虑后续的变异、交叉等算子应该怎样对染色体上的基因进行操作，这些操作是否符合约束条件。</p><h3 id="实数编码方法"><a href="#实数编码方法" class="headerlink" title="实数编码方法"></a>实数编码方法</h3><p>遗传算法可以使用二进制串来表示整数和实数，但是使用二进制串表示的实数的精度受串长度（位数）的限制。由于需要提前确定该长度，因此最终可能由于二进制串太短导致精度不足或编码过长。</p><p>因此除了使用浮点表示方法外，使用实数值数组代替二进制串也是一种简单可行的方法。</p><p>比如将染色体设计为 $x_1x_2x_3$ ，其中 $x_1 = 1.57,x_2 = 2.89,x_3 = 3.68$ ，这就是一个实数编码的染色体。</p><blockquote><p>本文指的实数编码方法和浮点数编码方法是有区别的，前者指每个变量就是一个基因，用原始的实数数据进行编码，后者指用类似于 <code>IEEE754</code> 的格式先将浮点数转换成二进制数，再用来进行编码。</p></blockquote><h2 id="（二）生成初始种群"><a href="#（二）生成初始种群" class="headerlink" title="（二）生成初始种群"></a>（二）生成初始种群</h2><p>遗传算法的操作对象是一个群体，因此现需要准备一些表示起始搜索点的初始群体数据。对于启发式算法而言，更好的起始数据更有利于算法的搜索表现。</p><p>原则上，在不确定解的大致情况时，我们希望初始种群的群体尽量大，减少解得到的偶然性；基因尽量分散，使解的来源尽量广泛。</p><h2 id="（三）进行选择运算"><a href="#（三）进行选择运算" class="headerlink" title="（三）进行选择运算"></a>（三）进行选择运算</h2><p>选择运算也是遗传算法中的一种算子（Operator），选择操作从旧群体中以一定概率选择优良个体组成新的种群，以繁殖得到下一代个体。</p><p>这时就应该提到开始时定义的“适应度”，在自然界，适应度反映的是一个生物群体能否适应环境并在残酷竞争中存活下来；在遗传算法中，适应度反映的是一个解（染色体/个体）是否在我们的目标函数中表现得更优，比如上面规定的：路程是否更短，时间开销是否更小…….</p><p>适应度的大小应该和一个解的优质程度成正相关，假设一个种群的数量为 $M$，个体 $i$ 的适应度为 $f_i$ ，则个体被选取的概率为 </p><script type="math/tex; mode=display">P_i = \frac{f_i}{\sum_{k=1}^Mf_k} \qquad i = 1,2,\cdots,n</script><p>如下几种方法可以用来充当选择算子：</p><h3 id="俄罗斯轮盘赌"><a href="#俄罗斯轮盘赌" class="headerlink" title="俄罗斯轮盘赌"></a>俄罗斯轮盘赌</h3><p>一般而言，选择算子使用俄罗斯轮盘赌算法（Russian roulette），它的起源就是左轮手枪对赌自杀游戏</p><blockquote><p>不错，这很战斗民族……</p><center><img src = https://s1.ax1x.com/2022/09/03/voVRWq.png width = 45%></center></blockquote><p>俄罗斯轮盘赌算法的操作过程如下：</p><ul><li>计算所有个体的适应度总和 $F = f_0 + f_1 + \cdots + f_n$</li><li>在 $[0,F]$ 之间生成一个随机数，并根据 $f_0,f_1,\cdots,f_n$ 的大小将 区间 $[0,F]$ 分成 $n$ 个“弹膛”</li><li>这个随机数落入哪个“弹膛”，就选择哪个“弹膛”对应的个体</li></ul><blockquote><p>一个个体的适应度越大，那么它对应的弹膛也就越大，被选中的概率就越高</p><p>由于这是一个基于随机数的算法，因此可能会出现适应度很高的个体却无法遗传至下一代的情况，这并不完全是缺点，因为它也保证了后代种群的演化多样性——最强大的个体不一定能活下来，大自然的戏剧性不也如此吗？</p></blockquote><h3 id="锦标赛选择"><a href="#锦标赛选择" class="headerlink" title="锦标赛选择"></a>锦标赛选择</h3><p>所有个体被随机选择，开展若干轮竞赛（两两竞赛/多个体竞赛），其中适应度最高的获胜并被选中。</p><blockquote><p>每轮锦标赛参与的个体数量称为锦标赛规模，而锦标赛的轮数一般由个体总数和锦标规模决定</p></blockquote><p>如果个体数量（$n$ 个）过多，保证个体进行两两竞赛是比较困难的（开展 $C_n^2$ 轮），此时可以先对个体进行分组淘汰</p><blockquote><p>对于符号编码的情况，可能需要考虑采用自行设计的选择算子</p></blockquote><h2 id="（四）进行配对和交叉操作"><a href="#（四）进行配对和交叉操作" class="headerlink" title="（四）进行配对和交叉操作"></a>（四）进行配对和交叉操作</h2><p>和生物学中的过程一样，进行交叉之前还应该先进行染色体的配对环节（也就是个体的配对），配对指的时从种群中随机选择两个个体进行组合，类似于自然界中的交配现象。</p><p>交叉操作则指对已经配对的两条染色体中的基因进行交换，有如下几种交叉算子支持这一操作的实现：</p><blockquote><p>以下是基于二进制编码（格雷码、浮点数编码）的交叉操作</p></blockquote><h3 id="单点交叉（Single-point-Crossover）"><a href="#单点交叉（Single-point-Crossover）" class="headerlink" title="单点交叉（Single-point Crossover）"></a>单点交叉（Single-point Crossover）</h3><p>在两条配对的染色体中随机设置一个位置交叉点，在该交叉位置对两条配对的染色体进行进行分割并交换位置交叉点右侧的染色体片段。</p><center><img src = https://s1.ax1x.com/2022/09/03/voV6oj.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVseg.png width = 41%></center><blockquote><p>单点交叉混合的速度较慢（因为将染色体分成两段进行交叉，这种方式交叉粒度较大），但对于选取交叉点位置具有一定内在含义的问题而言，单点交叉可以造成更小的破坏。</p></blockquote><h3 id="两点交叉（Two-points-Crossover）"><a href="#两点交叉（Two-points-Crossover）" class="headerlink" title="两点交叉（Two-points Crossover）"></a>两点交叉（Two-points Crossover）</h3><p>两点交叉是指在个体染色体中随机设置了两个交叉点，然后再将两个交叉点之间的染色体片段进行交换。</p><center><img src = https://s1.ax1x.com/2022/09/03/voVgFs.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVywQ.png width = 39.5%></center><h3 id="多点交叉（Multi-point-Crossover）"><a href="#多点交叉（Multi-point-Crossover）" class="headerlink" title="多点交叉（Multi-point Crossover）"></a>多点交叉（Multi-point Crossover）</h3><p>多点交叉或称广义交叉，是指在个体染色体中随机设置多个交叉点，然后在这些点的位置进行单个基因的交换。</p><center><img src = https://s1.ax1x.com/2022/09/03/voV2Yn.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVfS0.png width = 38.6%></center><h3 id="均匀交叉（Uniform-Crossover）"><a href="#均匀交叉（Uniform-Crossover）" class="headerlink" title="均匀交叉（Uniform Crossover）"></a>均匀交叉（Uniform Crossover）</h3><p>均匀交叉也称一致交叉，这个交叉算子遍历两个染色体的全部基因位点，每个基因位点都有相同的交叉概率发生在两个染色体间的交叉互换，效果如下：</p><center><img src = https://s1.ax1x.com/2022/09/03/voVhlV.png width = 45%></center><blockquote><p>以下是实数编码的交叉操作</p></blockquote><h3 id="算术交叉"><a href="#算术交叉" class="headerlink" title="算术交叉"></a>算术交叉</h3><p>算术交叉算子是一种适用于实数编码的交叉操作，它将父母两个个体的染色体进行线性组合，进而产生的新的个体。</p><script type="math/tex; mode=display">X_A^{t+1} = \alpha X_B^{t} + (1-\alpha)X_A^{t}</script><script type="math/tex; mode=display">X_B^{t+1} = \alpha X_A^t + (\alpha-1)X_B^t</script><p>上式中的 $\alpha$ 是一个参数，它可以是常数或者进化代数决定的变量，如果是后者的情况，此时的交叉变换就称为非均匀交叉变换。</p><h3 id="混合交叉（blend-crossover）"><a href="#混合交叉（blend-crossover）" class="headerlink" title="混合交叉（blend crossover）"></a>混合交叉（blend crossover）</h3><p>混合交叉算子是一种适用于实数编码的交叉操作，在混合交叉中，每个后代都是从其亲代创建的以下区间中<strong>随机</strong>选择的：</p><script type="math/tex; mode=display">X^{t+1}\in [X^t_1-\alpha (X^t_2 - X^t_1),\;X_2^t+\alpha(X_2^t - X_1^t)</script><blockquote><p>该式假设 $X_2^t &gt; X_1^t$ ，实际情况灵活处理</p></blockquote><p>$\alpha$ 是一个预确定的参数，其值在 $0$ 到 $1$ 之间，$\alpha$ 越大，区间就越大。</p><blockquote><p>$\alpha=0$ 时，选取范围就在两个亲代之间。</p></blockquote><h3 id="模拟二进制交叉（Simulated-Binary-Crossover）"><a href="#模拟二进制交叉（Simulated-Binary-Crossover）" class="headerlink" title="模拟二进制交叉（Simulated Binary Crossover）"></a>模拟二进制交叉（Simulated Binary Crossover）</h3><p>模拟二进制交叉算子是一种适用于实数编码的交叉操作，在模拟二进制交叉中，每个后代都是由亲代染色体创建的以下等式决定的：</p><script type="math/tex; mode=display">X_1^{t+1} = \frac{1}{2}(1+\beta)X_1^t+\frac{1}{2}(1-\beta)X_2^t</script><script type="math/tex; mode=display">X_2^{t+1} = \frac{1}{2}(1-\beta)X_1^t+\frac{1}{2}(1+\beta)X_2^t</script><p>模拟二进制交叉算子的特性是：</p><ul><li>不管 $\beta$ 的值如何，两个后代的平均值等于两个亲代的平均值</li><li>当 $\beta$ 的值为 $1$ 时，后代是双亲的副本</li><li>当 $\beta$ 值小于 1 时，后代间的距离比亲代间的距离更短</li><li>当 $\beta$ 值大于 1 时，后代间的距离比双亲间的距离更远</li></ul><center><img src = https://s1.ax1x.com/2022/09/03/voV7TJ.png width = 45%></center><blockquote><p>对于符号编码的情况，可能需要考虑采用自行设计的交叉算子</p><p>更多交叉方法可以参见 <a href="https://blog.csdn.net/u010743448/article/details/108445588">https://blog.csdn.net/u010743448/article/details/108445588</a> ，这里不作完全枚举</p></blockquote><h2 id="（五）变异"><a href="#（五）变异" class="headerlink" title="（五）变异"></a>（五）变异</h2><p>为了防止遗传算法在优化过程中陷入局部最优解，在搜索过程中，需要对个体进行变异操作，并以此更准确地模拟自然选择的过程。</p><p>变异是产生新的基因和个体的重要方式，往往能在遗传算法中起到随机搜索避免陷入局部最优的效果。但是如果变异概率过高，会导致变异过于频繁而丢失优秀的个体。</p><blockquote><p>下面是适用于基于二进制的编码（包括格雷码、浮点数编码）的变异算子</p></blockquote><h3 id="位翻转突变（Flip-Bit-Mutation）"><a href="#位翻转突变（Flip-Bit-Mutation）" class="headerlink" title="位翻转突变（Flip Bit Mutation）"></a>位翻转突变（Flip Bit Mutation）</h3><p>适用于以二进制为基础的编码方式，比如自然二进制编码法、格雷编码法和浮点数编码法。</p><p>算法流程非常简单：在随机选择若干个基因，将其值进行翻转（$01$互换 ）</p><center><img src = https://s1.ax1x.com/2022/09/03/voV4yT.png width = 66%></center><h3 id="交换突变（Swap-Mutation）"><a href="#交换突变（Swap-Mutation）" class="headerlink" title="交换突变（Swap Mutation）"></a>交换突变（Swap Mutation）</h3><p>随机选择若干对个基因并交换一对基因中的两个值</p><center><img src = https://s1.ax1x.com/2022/09/03/voV5OU.png width = 66%></center><p>这个突变算子适用于有序列表的染色体，因为新染色体仍带有与原始染色体相同的基因，如果是无序染色体，交换突变将会失效。</p><h3 id="反转突变（Inversion-Mutation）"><a href="#反转突变（Inversion-Mutation）" class="headerlink" title="反转突变（Inversion Mutation）"></a>反转突变（Inversion Mutation）</h3><p>选择一段随机的染色体片段（基因序列），将该序列中的基因顺序颠倒</p><center><img src = https://s1.ax1x.com/2022/09/03/voVomF.png width = 66%></center><p>同样，这个突变算子仅适用于有序列表的染色体。</p><blockquote><p>下面是适用于基于实数编码方法的变异算子</p></blockquote><h3 id="高斯变异"><a href="#高斯变异" class="headerlink" title="高斯变异"></a>高斯变异</h3><p>高斯变异算子通过用一个均值 $\mu$ 、方差为 $\sigma$ 的正态分布的一个随机数来替换原有基因值 $u$。</p><p>高斯变异的局部搜索能力较好，但是引导个体跳出局部较优解的能力较弱，不利于全局收敛。</p><h3 id="步长变异"><a href="#步长变异" class="headerlink" title="步长变异"></a>步长变异</h3><p>步长变异算子通过给变异基因加上或减去一个称为步长的值来实现变异的效果，即：</p><script type="math/tex; mode=display">X^{t+1} = X^{t} + Ld</script><blockquote><p>对于符号编码的情况，可能需要考虑采用自行设计的变异算子</p></blockquote><h2 id="检查退出条件"><a href="#检查退出条件" class="headerlink" title="检查退出条件"></a>检查退出条件</h2><p>通过检查经过选择、遗传、交叉和变异这些过程后得到的新种群是否满足预设的判断条件。如果满足，退出循环迭代体系；如果不满足，则将当前的种群加入下一轮循环迭代</p><p>至此，一个遗传算法的完整流程可以被总结如下——</p><p>一个基本的遗传算法至少需要确定四个运行参数：</p><ul><li>种群大小 $M$</li><li>遗传算法的终止进化代数 $T$<blockquote><p>用于设置预定义的遗传算法结束条件</p></blockquote></li><li>交叉概率 $PC$</li><li>变异概率 $PM$</li></ul><p>整合上面的各个过程，一个基本的遗传算法框架如下：</p><center><img src = https://s1.ax1x.com/2022/09/03/voVTw4.png width = 50%></center><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="代码框架详见下篇：遗传算法的代码构建"><a href="#代码框架详见下篇：遗传算法的代码构建" class="headerlink" title="代码框架详见下篇：遗传算法的代码构建"></a>代码框架详见下篇：遗传算法的代码构建</h2><h2 id="其它补充"><a href="#其它补充" class="headerlink" title="其它补充"></a>其它补充</h2><p>遗传算法发展至今已经加入了很多全新并且深刻的内容，比如变异方法、选择方法、交叉方法的改进版本，如柯西变异、混沌变异这样的新名词不断浮现。</p><p>本文旨在于给出一个最基本的遗传算法框架，实际情况使用的模型往往是需要不断修正、补充和丰富的。</p><h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong><center>参考文献：</center></strong></h1><blockquote><p>格雷码和俄罗斯轮盘赌算法的简介部分：<a href="http://accu.cc/content/ga/russian_roulette/">http://accu.cc/content/ga/russian_roulette/</a></p><p>遗传算法简介部分：<a href="https://zhuanlan.zhihu.com/p/100337680">https://zhuanlan.zhihu.com/p/100337680</a></p><p>遗传算法交叉算子部分：<a href="https://blog.csdn.net/u010743448/article/details/108445588">https://blog.csdn.net/u010743448/article/details/108445588</a> &amp; <a href="https://benpaodewoniu.github.io/2018/10/27/es4/">https://benpaodewoniu.github.io/2018/10/27/es4/</a> &amp; <a href="https://zhuanlan.zhihu.com/p/435885104">https://zhuanlan.zhihu.com/p/435885104</a></p><p>遗传算法变异算子部分：<a href="https://zhuanlan.zhihu.com/p/435885104">https://zhuanlan.zhihu.com/p/435885104</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性与非线性规划（一）</title>
      <link href="/2022/08/18/%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%80/"/>
      <url>/2022/08/18/%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）知识基础"><a href="#（一）知识基础" class="headerlink" title="（一）知识基础"></a>（一）知识基础</h1><h2 id="规划问题定义"><a href="#规划问题定义" class="headerlink" title="规划问题定义"></a>规划问题定义</h2><ul><li>线性规划：在一组线性约束条件的限制下，求一线性目标函数最大或者最小的问题。</li></ul><blockquote><p>线性意味着所有变量都是一次方的</p></blockquote><ul><li>非线性规划：在一组非线性约束条件（也可以包含线性条件）的限制下，求一线性目标函数最大或者最小的问题。</li></ul><blockquote><p>“也可以包含线性条件”是指非线性规划的约束条件可以是线性和非线性混合的</p></blockquote><h2 id="规划问题关键要素"><a href="#规划问题关键要素" class="headerlink" title="规划问题关键要素"></a>规划问题关键要素</h2><ul><li><p>决策变量：决策中待决定的自变量</p></li><li><p>目标函数：取决于决策变量的函数</p></li><li><p>约束条件：决策变量应该符合的基本条件</p></li></ul><h2 id="规划类优化问题类型"><a href="#规划类优化问题类型" class="headerlink" title="规划类优化问题类型"></a>规划类优化问题类型</h2><ul><li>连续优化<ul><li>线性规划问题（$LP$）：目标和约束函数为线性函数</li><li>非线性规划（$NLP$）：目标或约束中存在非线性函数</li><li>二次规划（$QP$）：目标为二次函数，约束为线性函数</li></ul></li><li>离散优化<ul><li>整数线性规划（$ILP$）：决策变量（部分或全部）为整数的线性规划问题</li><li>整数非线性规划（$INLP$）：决策变量（部分或全部）为整数的非线性规划问题</li><li>$0$-$1$ 规划（$ZOP$）：决策变量为 $0$ 或 $1$ 的规划问题</li></ul></li></ul><h1 id="（二）单目标线性规划"><a href="#（二）单目标线性规划" class="headerlink" title="（二）单目标线性规划"></a>（二）单目标线性规划</h1><h2 id="linprog-函数"><a href="#linprog-函数" class="headerlink" title="linprog 函数"></a>linprog 函数</h2><h3 id="函数模型"><a href="#函数模型" class="headerlink" title="函数模型"></a>函数模型</h3><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tar_x, tar_value] <span class="built_in">=</span> linprog(tar_fun, A, b, Aeq, beq ,lb, ub);</span><br></pre></td></tr></table></figure><p>参数解释</p><ul><li><p><code>tar_fun</code> 表示目标函数</p></li><li><p><code>A</code> 表示不等式约束条件系数矩阵</p></li><li><p><code>b</code> 表示不等式约束条件常数矩阵</p></li><li><p><code>Aeq</code> 表示等式约束条件系数矩阵</p></li><li><p><code>beq</code> 表示等式约束条件常数矩阵</p></li><li><p><code>lb</code> 表示决策变量的下限数组</p></li><li><p><code>ub</code>表示决策变量的上限数组</p></li></ul><blockquote><p>由于 <code>tar_fun</code> 是线性函数，那么直接代入它的系数数组即可（按顺序对应变量）</p><p>对于不存在的约束，在 <code>MATLAB</code> 中可以直接用空矩阵 <code>[]</code> 代替</p></blockquote><p>返回值解释</p><ul><li><p><code>tar_x</code> 表示目标函数 <code>tar_fun</code> 取得最小值时的决策变量取值数组</p></li><li><p><code>tar_value</code> 表示目标函数 <code>tar_fun</code> 取得的最小值</p></li></ul><blockquote><p>对于要求最大值的情形，取相反数作为目标函数代入即可</p></blockquote><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>设有线性规划问题如下：</p><p>不等式约束条件为：</p><script type="math/tex; mode=display">x_1+x_2\le2</script><script type="math/tex; mode=display">x_1+\frac{x_2}{4}\le1</script><script type="math/tex; mode=display">x_1-x_2\le2</script><script type="math/tex; mode=display">-\frac{x_1}{4}-x_2\le1</script><script type="math/tex; mode=display">-x_1-x_2\le-1</script><script type="math/tex; mode=display">-x_1+x_2\le2</script><p>等式约束条件为：</p><script type="math/tex; mode=display">x_1 + \frac{x_2}{4} = \frac{1}{2}</script><p>决策变量上下界为：</p><script type="math/tex; mode=display">-1\le x_1\le1.5</script><script type="math/tex; mode=display">-0.5\le x_2\le1.25</script><p>目标函数是：</p><script type="math/tex; mode=display">-x_1-\frac{x_2}{3}</script><p>将不等式和等式约束条件写成矩阵的形式：</p><script type="math/tex; mode=display">\begin{pmatrix}1&1\\1&\frac{1}{4}\\1&-1\\-\frac{1}{4}&-1\\-1&-1\\-1&1\end{pmatrix}\begin{pmatrix}x_1\\x_2   \end{pmatrix}\le\begin{pmatrix}2\\1\\2\\1\\-1\\2    \end{pmatrix}</script><script type="math/tex; mode=display">\begin{pmatrix}1&\frac{1}{4}\end{pmatrix}\begin{pmatrix}x_1\\x_2    \end{pmatrix}=\frac{1}{2}</script><p>调用函数解决：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tar_fun <span class="built_in">=</span> [-<span class="number">1</span> -<span class="number">1</span>/<span class="number">3</span>]; <span class="comment">% 目标函数</span></span><br><span class="line">A <span class="built_in">=</span> [<span class="number">1</span> <span class="number">1</span> ; <span class="number">1</span> <span class="number">1</span>/<span class="number">4</span> ; <span class="number">1</span> -<span class="number">1</span> ; -<span class="number">1</span>/<span class="number">4</span> -<span class="number">1</span> ; -<span class="number">1</span> -<span class="number">1</span> ; -<span class="number">1</span> <span class="number">1</span> ];</span><br><span class="line">b <span class="built_in">=</span> [<span class="number">2</span> ; <span class="number">1</span> ; <span class="number">2</span> ; <span class="number">1</span> ; -<span class="number">1</span> ; <span class="number">2</span>];</span><br><span class="line">Aeq <span class="built_in">=</span> [<span class="number">1</span> <span class="number">1</span>/<span class="number">4</span>];</span><br><span class="line">beq <span class="built_in">=</span> [<span class="number">1</span>/<span class="number">2</span>];</span><br><span class="line">lb <span class="built_in">=</span> [-<span class="number">1</span> -<span class="number">0.5</span>];</span><br><span class="line">ub <span class="built_in">=</span> [<span class="number">1.5</span> <span class="number">1.25</span>];</span><br><span class="line"></span><br><span class="line">[tar_x, tar_value] <span class="built_in">=</span> linprog(tar_fun, A, b, Aeq, beq ,lb, ub);</span><br></pre></td></tr></table></figure><p>如果成功调用并且结果正确，会在命令行区显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [tar_x, tar_value] = linprog(tar_fun, A, b, Aeq, beq ,lb, ub);</span><br><span class="line"></span><br><span class="line">Optimal solution found.</span><br></pre></td></tr></table></figure><h2 id="intlinplog-函数"><a href="#intlinplog-函数" class="headerlink" title="intlinplog 函数"></a>intlinplog 函数</h2><p><code>intlinplog</code> 函数主要用于处理整数线性规划问题。</p><p>和 <code>linplog</code> 使用方法基本一致，唯一的不同是：<code>intlinplog</code> 函数在参数列表的第一个参数后插入了一个类型为数组的参数：<code>intcon</code>，这个参数数组的涵义是指明决策变量数组中的第几个变量为整数变量</p><p>比如 <code>intcon = [1, 5]</code> 表示决策变量中 $x_1$ 和 $x_5$ 是整数变量</p><p>假设上面的例子中第二个变量即 $x_2$ 是整数变量，那么调用函数应该这样修改：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intcon <span class="built_in">=</span> [<span class="number">2</span>];</span><br><span class="line">[tar_x, tar_value] <span class="built_in">=</span> intlinprog(tar_fun, intcon, A, b, Aeq, beq ,lb, ub);</span><br></pre></td></tr></table></figure><p>调用这个函数会给出以下提醒：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; [tar_x, tar_value] = intlinprog(tar_fun, intcon, A, b, Aeq, beq ,lb, ub);</span><br><span class="line"></span><br><span class="line">LP:                Optimal objective value is -0.583333.                                            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimal solution found.</span><br><span class="line"></span><br><span class="line">Intlinprog stopped at the root node because the objective value is within a gap tolerance of the</span><br><span class="line">optimal value, options.AbsoluteGapTolerance = 0 (the default value). The intcon variables are</span><br><span class="line">integer within tolerance, options.IntegerTolerance = 1e-05 (the default value).</span><br></pre></td></tr></table></figure><p>请不要惊慌——这不是报错，它表示：这个解法得到的结果可能实际上不一定是一个整数，但是它已经尽可能地进行精确，并且当前的误差为 <code>1e-05</code> 即 $0.00001$（你也可以将这个误差允许值设置得更小），它已经在这个误差内得到了结果。</p><h1 id="（三）单目标非线性规划"><a href="#（三）单目标非线性规划" class="headerlink" title="（三）单目标非线性规划"></a>（三）单目标非线性规划</h1><h2 id="使用-LINGO-进行优化（推荐）"><a href="#使用-LINGO-进行优化（推荐）" class="headerlink" title="使用 LINGO 进行优化（推荐）"></a>使用 <code>LINGO</code> 进行优化（推荐）</h2><p><code>LINGO</code> 是一款专门用于解决规划类问题的软件。在处理线性规划问题上，和 <code>MATLAB</code> 相比，<code>LINGO</code> 更具有优势：</p><ul><li>可以支持二维决策变量</li><li>求解 <code>NLP</code> 问题时不需要进行初值估计</li><li>使用集合命令，更加直观，方便描述复杂条件</li><li>不需要人为指定算法，减少了理解算法的过程</li></ul><p>请移步 <a href="https://www.lixinbook.cn/2022/08/18/LINGO%E6%8C%87%E5%8D%97/"><code>LINGO</code> 入门教程</a> </p><h2 id="调用-MATLAB-的-fmincon-函数进行优化"><a href="#调用-MATLAB-的-fmincon-函数进行优化" class="headerlink" title="调用 MATLAB 的 fmincon 函数进行优化"></a>调用 <code>MATLAB</code> 的 <code>fmincon</code> 函数进行优化</h2><p><code>MATLAB</code> 的 <code>fmincon</code> 函数也是进行非线性规划的函数。</p><p>但是由于该函数的内置算法可能会收敛到局部极小值，因此初值的选取可能会对结果造成影响。</p><center><img src = https://pic4.zhimg.com/80/v2-c8c7afc6069d1325a54817d62ba7e5b8.png width = 50%></center><h3 id="函数模型-1"><a href="#函数模型-1" class="headerlink" title="函数模型"></a>函数模型</h3><p>调用形式如下：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tar_x, tar_value] <span class="built_in">=</span> fmincon(tar_fun, x0, A, b, Aeq, beq ,lb, ub, nonlcon, options);</span><br></pre></td></tr></table></figure><p>参数解释</p><ul><li><p><code>tar_fun</code> 表示目标函数，由自己编写</p><blockquote><p>非线性函数的 <code>tar_fun</code> 已经不能再使用数组进行描述（这种方法只适用于线性函数描述）</p><p>有两个方法可以解决这个问题，一是定义为匿名函数（见使用示例），二是在同一文件夹下定义函数文件（见使用示例），两个方法都需要使用 <code>@</code> 进行传参</p><p><code>@</code> 其实是 <code>MATLAB</code> 中的一种称为函数句柄的语法，实质类似于面向对象语言的函数对象</p></blockquote></li><li><p><code>x0</code> 表示决策变量搜索的起点数组</p><blockquote><p>增添了 <code>x0</code> 参数，是因为 <code>fmincon</code> 采用的梯度下降方法可能会陷入局部最优，所以一定程度上依赖于初值的选取</p></blockquote></li><li><p><code>A</code> 表示不等式约束条件系数矩阵</p></li><li><p><code>b</code> 表示不等式约束条件常数矩阵</p></li><li><p><code>Aeq</code> 表示等式约束条件系数矩阵</p></li><li><p><code>beq</code> 表示等式约束条件常数矩阵</p></li><li><p><code>lb</code> 表示决策变量的下限数组</p></li><li><p><code>ub</code>表示决策变量的上限数组</p></li><li><p><code>nonlcon</code> 表示非线性约束，也由自己编写</p><blockquote><p>该变量需要 <code>@</code> 一个以决策变量数组 <code>x</code> 为输入，以<strong>标准化形式后</strong>的两个非线性代数式数组为输出的函数，详见使用示例</p></blockquote></li><li><p><code>options</code> 表示函数的设置选项，该参数可选</p><blockquote><p><code>fmincon</code> 里面涉及到诸多内置算法的选择，但一般情况下我们不会修改 <code>options</code></p><p>修改参数可以参见该<a href="https://ww2.mathworks.cn/help/optim/ug/fmincon.html#busog7r-options">网站</a> ，了解内置算法可以参见该<a href="https://ww2.mathworks.cn/help/optim/ug/constrained-nonlinear-optimization-algorithms.html#brnpd5f">网站</a> ，点击跳转</p></blockquote></li></ul><p>返回值解释</p><ul><li><p><code>tar_x</code> 表示目标函数 <code>tar_fun</code> 取得最小值时的决策变量取值数组</p></li><li><p><code>tar_value</code> 表示目标函数 <code>tar_fun</code> 取得的最小值</p></li></ul><p>此外还可以用下面的语法接收更多的返回值：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval, exitflag, output] <span class="built_in">=</span> fmincon(tar_fun, x0, A, b, Aeq, beq ,lb, ub, nonlcon)</span><br></pre></td></tr></table></figure><ul><li><code>exitflag</code> 表示 <code>fmincon</code> 退出条件</li><li><code>output</code> 表示优化过程信息结构体</li></ul><blockquote><p>该部分参见<a href="https://ww2.mathworks.cn/help/optim/ug/fmincon.html">官方文档（点击跳转）</a> ，如果觉得当前内容不够详细，可以访问官网获取更详尽的内容</p></blockquote><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设我们要求解一个多元单目标非线性规划，如下：</p><script type="math/tex; mode=display">tar\_fun =  e^{sin (x_1^3 + cos x_2)} - log_3(e^{x_3}+sin(x_4cos{x_5}))</script><p>线性约束条件为</p><script type="math/tex; mode=display">x_1 + x_2 = 0</script><script type="math/tex; mode=display">x_3 \ge 0</script><script type="math/tex; mode=display">x_1 + x_3 \le 30</script><script type="math/tex; mode=display">x_2 + x_3 + 2x_4 \ge 0</script><p>非线性约束为</p><script type="math/tex; mode=display">e^{sin(x_1)} - 2 e^{cos(2x_5)} = 0</script><script type="math/tex; mode=display">x_2^2-x_3^3+x_4^2\le2</script><p>所有变量的上下界条件为 $[-50,50]$</p><ul><li>第一步：编写目标函数文件</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 目标函数文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% value 是一个值，即我们优化的目标</span></span><br><span class="line"><span class="comment">% x 是决策变量数组，在本题中一共由五个变量构成</span></span><br><span class="line">function value <span class="built_in">=</span> tar_fun(x)</span><br><span class="line">    value <span class="built_in">=</span> exp(sin(x(<span class="number">1</span>) ^ <span class="number">3</span> + cos(x(<span class="number">2</span>)))) - log(exp(x(<span class="number">3</span>)) + sin(x(<span class="number">4</span>) * cos(x(<span class="number">5</span>))) / log(<span class="number">3</span>));</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>第二步：编写非线性约束文件</li></ul><p>非线性函数返回的应该是两个数组，第一个数组为 <code>c(x)</code>，即由 <code>x</code> 处的非线性不等式约束组成的数组；第二个数组为 <code>ceq(x)</code>，即由 <code>x</code> 处的线性不等式约束组成的数组。</p><p>比如上面的例子，我们编写的非线性约束文件应该是：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% c(x) 是由 x 处的非线性不等式约束组成的数组</span></span><br><span class="line"><span class="comment">% ceq(x) 是由 x 处的线性不等式约束组成的数组</span></span><br><span class="line">function [c, ceq] <span class="built_in">=</span> nonlcon(x)</span><br><span class="line">    c <span class="built_in">=</span> x(<span class="number">2</span>) ^ <span class="number">2</span> - x(<span class="number">3</span>) ^ <span class="number">3</span> + x(<span class="number">4</span>) ^ <span class="number">2</span> - <span class="number">2</span>;        <span class="comment">% 不等式条件</span></span><br><span class="line">    ceq <span class="built_in">=</span> exp(sin(x(<span class="number">1</span>))) - <span class="number">2</span> * exp(cos(<span class="number">2</span> * x(<span class="number">5</span>))); <span class="comment">% 等式条件</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>注意：对于非线性不等式，约束的形式应该满足 <code>c(x) &lt;= 0</code>，如果不满足这一条件应该进行移项</p></blockquote><ul><li>第三步：编写主文件</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A <span class="built_in">=</span> [<span class="number">0</span> <span class="number">0</span> -<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">2</span> <span class="number">0</span>]; <span class="comment">% 线性不等式约束系数矩阵</span></span><br><span class="line">b <span class="built_in">=</span> [<span class="number">0</span> <span class="number">30</span> <span class="number">0</span>];                              <span class="comment">% 线性不等式约束常数矩阵</span></span><br><span class="line">Aeq <span class="built_in">=</span> [<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];                         <span class="comment">% 线性等式约束系数矩阵</span></span><br><span class="line">beq <span class="built_in">=</span> [<span class="number">0</span>];                                 <span class="comment">% 线性等式约束常数矩阵</span></span><br><span class="line">x0 <span class="built_in">=</span> [<span class="number">2</span> -<span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span>];                         <span class="comment">% 初始条件                     </span></span><br><span class="line">lb <span class="built_in">=</span> [-<span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span>];                <span class="comment">% 下界</span></span><br><span class="line">ub <span class="built_in">=</span> [<span class="number">50</span> <span class="number">50</span> <span class="number">50</span> <span class="number">50</span> <span class="number">50</span>];                     <span class="comment">% 下界</span></span><br><span class="line">MaxValue <span class="built_in">=</span> <span class="number">10</span>e99;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 提高计算次数上限</span></span><br><span class="line">options <span class="built_in">=</span> optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Display&#x27;</span>,<span class="string">&#x27;iter&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;sqp&#x27;</span>, <span class="string">&#x27;MaxFunctionEvaluations&#x27;</span>,MaxValue);</span><br><span class="line"></span><br><span class="line">[tar_x, tar_val] <span class="built_in">=</span> fmincon(@tar_fun, x0, A, b, Aeq, beq ,[], [], @nonlcon, options); <span class="comment">% 调用 fmincon 函数</span></span><br></pre></td></tr></table></figure><blockquote><p>这个函数能跑，but 由于模型过于复杂跑不出来，不想改了.jpg，此处只是向大家展示一下正确语法（上述代码语法完全正确）</p></blockquote><h2 id="调用-MATLAB-的全局优化算法进行优化"><a href="#调用-MATLAB-的全局优化算法进行优化" class="headerlink" title="调用 MATLAB 的全局优化算法进行优化"></a>调用 <code>MATLAB</code> 的全局优化算法进行优化</h2><p>MATLAB的全局优化工具箱提供了一些不错的全局优化算法，这个是它们的<a href="https://ww2.mathworks.cn/products/global-optimization.html#global-search-multistart">文档（点击跳转）</a></p><h3 id="一些函数如下"><a href="#一些函数如下" class="headerlink" title="一些函数如下"></a>一些函数如下</h3><h4 id="多点搜索（GlobalSearch-amp-MultiStart）"><a href="#多点搜索（GlobalSearch-amp-MultiStart）" class="headerlink" title="多点搜索（GlobalSearch &amp; MultiStart）"></a>多点搜索（<code>GlobalSearch</code> &amp; <code>MultiStart</code>）</h4><p>在《优化算法补充》中介绍</p><h4 id="替代优化（surrogateopt）"><a href="#替代优化（surrogateopt）" class="headerlink" title="替代优化（surrogateopt）"></a>替代优化（<code>surrogateopt</code>）</h4><p>在《优化算法补充》中介绍</p><h4 id="模式搜索（patternsearch）"><a href="#模式搜索（patternsearch）" class="headerlink" title="模式搜索（patternsearch）"></a>模式搜索（<code>patternsearch</code>）</h4><p>在《优化算法补充》中介绍</p><h4 id="遗传算法（ga）"><a href="#遗传算法（ga）" class="headerlink" title="遗传算法（ga）"></a>遗传算法（<code>ga</code>）</h4><p>在《现代优化算法》中介绍</p><h4 id="粒子群算法（particleswarm）"><a href="#粒子群算法（particleswarm）" class="headerlink" title="粒子群算法（particleswarm）"></a>粒子群算法（<code>particleswarm</code>）</h4><p>在《现代优化算法》中介绍</p><h4 id="模拟退火（simulannealbnd）"><a href="#模拟退火（simulannealbnd）" class="headerlink" title="模拟退火（simulannealbnd）"></a>模拟退火（<code>simulannealbnd</code>）</h4><p>在《现代优化算法》中介绍</p><h4 id="多目标规划（gamultiobj-amp-paretosearch）"><a href="#多目标规划（gamultiobj-amp-paretosearch）" class="headerlink" title="多目标规划（gamultiobj &amp; paretosearch）"></a>多目标规划（<code>gamultiobj</code> &amp; <code>paretosearch</code>）</h4><p>在《线性和非线性规划（二）》中介绍</p><blockquote><p>备注：《线性和非线性规划（二）》、《优化算法补充》和《现代优化算法》都是本系列的内容，后续更新</p><p>《线性和非线性规划（二）》介绍多目标规划</p><p>《优化算法补充》介绍多点搜索（<code>GlobalSearch</code> &amp; <code>MultiStart</code>）、替代优化（<code>surrogateopt</code>）和模式搜索（<code>patternsearch</code>）</p><p>《现代优化算法》主要介绍一些启发式算法，比如遗传算法（<code>ga</code>）、粒子群算法（<code>particleswarm</code>）和模拟退火（<code>simulannealbnd</code>），也会增加一些其它内容</p><p>敬请期待！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从马尔可夫链到 Page Rank 算法</title>
      <link href="/2022/08/18/%E4%BB%8E%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE%E5%88%B0PageRank%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/18/%E4%BB%8E%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE%E5%88%B0PageRank%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）背景介绍"><a href="#（一）背景介绍" class="headerlink" title="（一）背景介绍"></a>（一）背景介绍</h1><p>搜索技术的发展大致可以分为四个阶段，分类目录时期、文本检索时期、链接分析时期和以用户为中心的时期。链接分析时期的搜索引擎建立在文本检索的基础上，通过深入地分析网页中链接所隐含的信息，获取网页之间的“推荐关系”，通过对于链接地分析能够为用户推荐相关地网页，并进行精准地排名，极大改善了搜索质量和搜索体验。本文介绍的 $Page \ Rank$ 算法就是链接搜索领域的一个重要技术。</p><center><img src = https://s1.ax1x.com/2022/08/19/vrw9PI.png width = 50%></center><hr><h1 id="（二）知识基础"><a href="#（二）知识基础" class="headerlink" title="（二）知识基础"></a>（二）知识基础</h1><h2 id="随机游走模型"><a href="#随机游走模型" class="headerlink" title="随机游走模型"></a>随机游走模型</h2><p>给定一个含有 $n$ 个结点的有向图，在有向图上定义随机游走（$Random\ Walk$）模型：</p><p>图的每个节点结点表示一个特定的状态，有向边则用来表示状态之间的转移，假设从一个结点到通过有向边相连的所有结点的转移概率相等。</p><p>假设状态从图的节点 $i$ 转移到节点 $j$ 的概率为 $m_{ij}$ ，将 $m_{ij}$ 作为一个矩阵的第 $i$ 行第 $j$ 列上的元素，那么就能构成一个大小为 （节点个数 $\times$ 节点个数）的矩阵，它被我们定义称转移矩阵 $M$</p><p>设转移矩阵 $M$ 的节点个数是 $n$ 。事实上，根据概率基本事实即可知以下结论总是成立：</p><script type="math/tex; mode=display">    m_{1j}+m_{2_j}+m_{3j}+\cdots+m_{nj}=\sum_{i=1}^nm_{ij}=1, \; j=1,2,\cdots,n</script><p>这个模型就被称为随机游走模型，随机游走模型是马尔可夫链的基础。</p><h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><h3 id="马尔可夫链概念介绍"><a href="#马尔可夫链概念介绍" class="headerlink" title="马尔可夫链概念介绍"></a>马尔可夫链概念介绍</h3><p>马尔可夫链是一种假设某一状态转移的概率只依赖于它的前一个状态的模型。用数学语言可以表达为：</p><script type="math/tex; mode=display">    P(X^{t+1}|X^0,X^1,X^2,\cdots,X^t) = P(X^{t+1}|X^t)</script><p>其中 $X^k$ 表示经过 $k$ 次状态转移后的当前状态，上述公式描述的是：当前状态仅和上一个状态有关，和上一个状态前的任意一个状态都无关。</p><p>概括而言，马尔可夫链应该具有核心三要素</p><ul><li><p>状态空间（$State\ Space$）：状态能且只能在若干个状态间进行转换</p></li><li><p>无记忆性（$Memorylessness$）：当期选择的概率只受到上期状态的影响</p></li><li><p>转移矩阵（$Transition\ Matrix$）： 我们可以使用一个矩阵来描述一个状态转移到所有状态（包括自身状态）的概率，如果不存在转移到某状态的路径，则直接用 $0$ 表示其概率。  </p><blockquote><p>有向图的表示方法有邻接矩阵和邻接表，而实际上这里的转移矩阵的实质是一种带权的邻接矩阵</p></blockquote></li></ul><h3 id="马尔可夫链的稳态"><a href="#马尔可夫链的稳态" class="headerlink" title="马尔可夫链的稳态"></a>马尔可夫链的稳态</h3><p>符合上述要求的马尔可夫链都会达到一个最终稳定的状态，如果我们将初始状态整合为一个状态向量，那么，每次得到的下一个状态向量的各状态概率可以用下式表示：</p><script type="math/tex; mode=display">\begin{pmatrix}X_1^i\\X_2^i\\\vdots\\X_n^i\end{pmatrix}=\begin{pmatrix}p_{11}&p_{12}&\cdots&p_{1n}\\p_{21}&p_{22}&\cdots&p_{2n}\\\vdots&\vdots&\ddots&\vdots\\p_{n1}&p_{n2}&\cdots&p_{nn}    \end{pmatrix}^i\begin{pmatrix}X_1^0\\X_2^0\\\vdots\\X_n^0\end{pmatrix}</script><p>其中 $X_j^i$ 表示第 $j$ 个状态经过 $i$ 次迭代后得到的状态， $P_{ab}$ 表示第 $a$ 个状态转移到第 $b$ 个状态的概率。</p><p>我们可以通过一个简单的例子描述这样的模型：</p><p>小离每天选择饮料时总是进行两种选择：$A$ 或 $B$ ，在选择 $A$ 后依旧选择 $A$ 的概率为 $40\%$ ，在选择 $A$ 后选择 $B$ 的概率为 $60\%$ ，在选择 $B$ 后依旧选择 $B$ 的概率为 $50\%$，在选择 $B$ 后选择 $A$ 的概率为 $50\%$。这样我们统计小离每天的饮料选择状态，会发现小离每天的饮料选择倾向于 $B$，并且概率为 $54.5455\%$ ，趋近于某种稳态。</p><center><img src = https://s1.ax1x.com/2022/08/19/vrwSIA.png width = 34.4%><img src = https://s1.ax1x.com/2022/08/19/vrdjqe.png width = 40%></center><h3 id="马尔可夫链的数学性质"><a href="#马尔可夫链的数学性质" class="headerlink" title="马尔可夫链的数学性质"></a>马尔可夫链的数学性质</h3><p>除此之外，对于马尔可夫链，我们还可以发现这样的数学性质：如果我们经过足够多次的转移矩阵 $M$ 迭代，得到的稳态矩阵为 $R$ ，那么实际上由以下两式可知 $R$ 是转移矩阵的特征向量。</p><script type="math/tex; mode=display">RM = R\\R(M-I)=O</script><blockquote><p>在这里我们当然可以借助高等代数的知识进行长篇大论的推演（应该会非常有趣），可是如何借助这个模型来实现一些服务于现实世界的程序，才是本文的重点部分。</p></blockquote><hr><h1 id="（三）Page-Rank-算法"><a href="#（三）Page-Rank-算法" class="headerlink" title="（三）Page Rank 算法"></a>（三）Page Rank 算法</h1><h2 id="Page-Rank-的基本定义"><a href="#Page-Rank-的基本定义" class="headerlink" title="Page Rank 的基本定义"></a>Page Rank 的基本定义</h2><p>由上面对于马尔可夫链的讨论可知，对于含有 $n$ 个节点的满足马尔可夫性质的有向图，我们在图上定义一个随机游走模型。</p><p>对于随机游走模型而言，从图上一个节点转移到与该节点连通的任何一个节点的概率相等。</p><blockquote><p>你可能有点疑惑为什么就认为 “从图上一个节点转移到与该节点连通的任何一个节点的概率相等”。这实际上是一个默认的设定，我们也可以基于显示因素定量或定性地修正这些概率的值</p></blockquote><p>而在 $Page Rank$ 模型中，我们设定每个节点都代表一个网页，节点之间的有向边就代表网页之间的链接关系：这样，网页群就被我们抽象成一张有向图。</p><p>根据这样的结果，我们不难直接定义出转移矩阵 $M$ ，可以证明，这种情况下，马尔可夫链也是具有最终平稳分布 $R$ 的。这样，只要得到最后的平稳分布，并且将平稳分布进行模长化（满足概率和为 $1$ 的分布要求），我们规定 $p(v_i)$ 为最终稳态分布中节点为 $v_i$ 的网页的“被访问概率”</p><script type="math/tex; mode=display">RM=R\ ;\qquadR=\begin{pmatrix}p(v_1)\\p(v_2)\\\vdots\\p(v_n)\end{pmatrix}\ ;\qquad\sum_{i=1}^np(v_i)=1\ ;</script><p>这是Page Rank中的基础模型，现实场景下，为了模拟复杂的情况，我们还需要对Page Rank模型进一步修正。</p><h2 id="Page-Rank-算法模型"><a href="#Page-Rank-算法模型" class="headerlink" title="Page Rank 算法模型"></a>Page Rank 算法模型</h2><p>为更加清晰地解释下文的内容，我们利用一个简单的网站链接模型作为例子。</p><p>如图，有五个网站，它们之间的链接关系如图所示</p><center><img src = https://s1.ax1x.com/2022/08/19/vrdxVH.png width = 30%></center><p>我们定义一个转移矩阵来描述网页之间的链接关系和概率</p><script type="math/tex; mode=display">\begin{pmatrix}1&\frac{1}{3}&0&0&0\\0&0&\frac{1}{2}&0&0\\0&\frac{1}{3}&0&1&1\\0&\frac{1}{3}&\frac{1}{2}&0&0\\0&0&0&0&0    \end{pmatrix}</script><blockquote><p>再强调一下：这个矩阵的第 $i$ 行第 $j$ 列元素表示从网页 $i$ 转移到网页 $j$ 的概率</p></blockquote><h3 id="规避转移到一个网站后无法继续转移的情况"><a href="#规避转移到一个网站后无法继续转移的情况" class="headerlink" title="规避转移到一个网站后无法继续转移的情况"></a>规避转移到一个网站后无法继续转移的情况</h3><p>如果进入到一个网站中，该网站不具有到任何其它网站的链接，那么一旦陷入这样的状态就会被当前页面局限而不再发生转移，这显然不是我们希望的状态。</p><p>这种情况在转换矩阵中体现为：一列中只有对角线元素为 $1$ 而其它元素为 $0$ 。</p><p>因此我们可以将这种不具备链接的网站近似成具备到所有其它网站的等效链接，即对矩阵的相关维的分量进行修正。</p><p>如假设一个页面转移矩阵的第一维分量为 $(1\quad0\quad0)$ ，则可以修正为 $(0.33\quad0.33\quad0.33)$ 。</p><p>同理，我们刚刚定义的转换矩阵应该修改为：</p><script type="math/tex; mode=display">\begin{pmatrix}\frac{1}{5}&\frac{1}{3}&0&0&0\\\frac{1}{5}&0&\frac{1}{2}&0&0\\\frac{1}{5}&\frac{1}{3}&0&1&1\\\frac{1}{5}&\frac{1}{3}&\frac{1}{2}&0&0\\\frac{1}{5}&0&0&0&0    \end{pmatrix}</script><h3 id="阻尼系数的引入"><a href="#阻尼系数的引入" class="headerlink" title="阻尼系数的引入"></a>阻尼系数的引入</h3><p>用户在点击进入网站时，除了使用通过链接到达其它相关的网站，还有另一种选择——就是直接通过引擎转到当前网页未链接的网站，这种情况在我们之前的模型中是一直缺乏考虑的。</p><p>我们引入一个“阻尼系数” $d$ ，将它定义为用户通过链接跳转的概率，那么 $1-d$ 就是用户直接通过搜索引擎跳转的概率，我们规定用户通过非链接方式前往各个网站的概率相等，那么新的转换矩阵 $S$ 应该满足下面的公式</p><script type="math/tex; mode=display">S = dM+(1-d)\frac{K}{n}</script><p>其中，$K$ 表示形状为（网页数$\times$网页数）且每个元素都是 $1$ 的矩阵。Google 的工程师统计得到 $d$ 取 $0.85$ 时效果最优。</p><p>下面展示了添加阻尼系数后的可视化数据：</p><center><img src = https://s1.ax1x.com/2022/08/19/vrdzad.png width = 45%></center><hr><h1 id="（四）Python-代码和-MATLAB-代码"><a href="#（四）Python-代码和-MATLAB-代码" class="headerlink" title="（四）Python 代码和 MATLAB 代码"></a>（四）Python 代码和 MATLAB 代码</h1><p>提供了两个版本的 $Page\ Rank$ 代码</p><blockquote><p>本文代码已经发布到 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm/Markov%E9%93%BE%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95">我的 GitHub 仓库</a>（点击跳转），可以直接前往下载。</p></blockquote><h2 id="MATLAB-版本"><a href="#MATLAB-版本" class="headerlink" title="MATLAB 版本"></a>MATLAB 版本</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function outrank <span class="built_in">=</span> pagerank(n, times, tran_mat)</span><br><span class="line">    <span class="comment">% n 是网页的个数</span></span><br><span class="line">    <span class="comment">% times 表示迭代次数，次数越大，精度越高</span></span><br><span class="line">    <span class="comment">% tran_mat 表示转移矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 设置阻尼</span></span><br><span class="line">    d <span class="built_in">=</span> <span class="number">0.85</span>;</span><br><span class="line">    bias <span class="built_in">=</span> ones(n, n);</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">        for j <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">            tran_mat <span class="built_in">=</span> d * tran_mat + (<span class="number">1</span> - d) * bias / n;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 矩阵乘法</span></span><br><span class="line"></span><br><span class="line">    value <span class="built_in">=</span> zeros(n, times);</span><br><span class="line">   </span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">        value(i,<span class="number">1</span>) <span class="built_in">=</span> <span class="number">1</span> / n;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">2</span> : times + <span class="number">1</span></span><br><span class="line">       value(:, i) <span class="built_in">=</span> tran_mat * value(:, i - <span class="number">1</span>); </span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 作图</span></span><br><span class="line">    curtime <span class="built_in">=</span> <span class="number">0</span> : <span class="number">1</span> : times;</span><br><span class="line">    colorGap <span class="built_in">=</span> fix(<span class="number">255</span>/n);</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">        plot(curtime,value(i, :),<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>, [i*colorGap/<span class="number">255</span>, <span class="number">127</span>/<span class="number">255</span>, (<span class="number">255</span> - i*colorGap)/<span class="number">255</span>]);</span><br><span class="line">        hold on;</span><br><span class="line">    end</span><br><span class="line">    xlabel(<span class="string">&quot;迭代次数&quot;</span>);</span><br><span class="line">    ylabel(<span class="string">&quot;状态值&quot;</span>);</span><br><span class="line">    legend(<span class="string">&quot;page1&quot;</span>,<span class="string">&quot;page2&quot;</span>,<span class="string">&quot;page3&quot;</span>,<span class="string">&quot;page4&quot;</span>,<span class="string">&quot;page5&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 归一化并返回最终结果</span></span><br><span class="line">    outrank <span class="built_in">=</span> zeros(n);</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">        outrank(i) <span class="built_in">=</span> value(i, times + <span class="number">1</span>)/sum(value(:,times + <span class="number">1</span>));</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">&#x27;darkgrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设有A，B，C，D，E五个网站</span></span><br><span class="line">n = <span class="number">5</span></span><br><span class="line">transfer_matrix = np.array(</span><br><span class="line">    [[<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>], [<span class="number">0.333</span>, <span class="number">0</span>, <span class="number">0.333</span>, <span class="number">0.333</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">start_matrix = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=<span class="string">&#x27;float32&#x27;</span>)  <span class="comment"># 从A页面开始浏览</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置阻尼系数并利用阻尼系数对转换矩阵进行修正</span></span><br><span class="line">d = <span class="number">0.85</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        transfer_matrix[i][j] *= d</span><br><span class="line">        transfer_matrix[i][j] += (<span class="number">1</span> - d) * (<span class="number">1</span> / n)</span><br><span class="line"></span><br><span class="line">value1 = []</span><br><span class="line">value2 = []</span><br><span class="line">value3 = []</span><br><span class="line">value4 = []</span><br><span class="line">value5 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    start_matrix = np.dot(start_matrix, transfer_matrix)</span><br><span class="line">    value1.append(start_matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    value2.append(start_matrix[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    value3.append(start_matrix[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">    value4.append(start_matrix[<span class="number">0</span>][<span class="number">3</span>])</span><br><span class="line">    value5.append(start_matrix[<span class="number">0</span>][<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行可视化</span></span><br><span class="line">x = np.arange(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, value1, label=<span class="string">&#x27;Apage&#x27;</span>)</span><br><span class="line">plt.plot(x, value2, label=<span class="string">&#x27;Bpage&#x27;</span>)</span><br><span class="line">plt.plot(x, value3, label=<span class="string">&#x27;Cpage&#x27;</span>)</span><br><span class="line">plt.plot(x, value4, label=<span class="string">&#x27;Dpage&#x27;</span>)</span><br><span class="line">plt.plot(x, value5, label=<span class="string">&#x27;Epage&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h1 id="（五）一点补充"><a href="#（五）一点补充" class="headerlink" title="（五）一点补充"></a>（五）一点补充</h1><p>我们稍微回顾一下最开头提出的马尔可夫链模型成立的三个条件</p><ul><li><p>状态空间（$State\ Space$）：状态能且只能在若干个状态间进行转换</p></li><li><p>无记忆性（$Memorylessness$）：当期选择的概率只受到上期状态的影响</p></li><li><p>转移矩阵（$Transition\ Matrix$）： 我们可以使用一个矩阵来描述一个状态转移到所有状态（包括自身状态）的概率，如果不存在转移到某状态的路径，则直接用 $0$ 表示其概率。  </p></li></ul><p>稍加辨析我们很容易发现现实生活中的网页链接模型事实上并不完全符合马尔科夫链的模型要求：</p><p>状态空间上，网页只能在若干网页之间进行链接跳转事实上并不完全符合现实生活中的情况，用户随时有可能做出我们规定了网页群外的其他网页选择。并且还有一些极端情况：某些网页甚至没有跳转到其他网页的链接。</p><p>无记忆性上，用户的若干连续网页跳转之间可能满足一定的逻辑规律，认为当期选择的概率只受上期状态的影响似乎也不完全符合现实。</p><p>转移矩阵上，我们似乎会发现一个不变的矩阵很难满足我们当前的需求：用户在浏览的过程中很有可能对他们的转移矩阵做出一定的更新。</p><p>然而，当我们考虑所有这些复杂的现实因素时，我们会发现建模成为了一件似乎不可能的事，拟和现实生活中的一切因素听起来很酷，却会使我们的建模成为一件混乱而复杂的事，不妨看看 $Page\ Rank$ 模型是怎么处理这些问题的：</p><ul><li><p>忽略网页群外的其他网页选择，将状态空间严格控制在一定的范围内，对于无法跳转到其他网页的链接，直接默认为拥有跳转到所有网页群内的网页的链接。</p></li><li><p>忽略用户连续网页跳转之间的规律，认为用户上一次浏览的网页对于接下来要浏览哪个网页而言具有绝对权重。</p></li><li><p>忽略用户在浏览过程中的一些情况导致的转移矩阵更新，因为不恒定的转移矩阵很有可能使马尔科夫链无法得到一个收敛的结果。</p></li></ul><p>因此，建模既是对现实世界的拟合，也是对现实世界的忽略——抽象必然伴随着忽略。事实也证明，先通过忽略的方式得到抽象的模型，然后在这基础上不断对模型进行基于现实的修正和更改，才是最佳的建模方法。</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锻炼左右脑协调的贪吃蛇游戏——《Double Snakes》完整 C 语言代码！</title>
      <link href="/2022/08/18/doublesnake/"/>
      <url>/2022/08/18/doublesnake/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）运行效果"><a href="#（一）运行效果" class="headerlink" title="（一）运行效果"></a>（一）运行效果</h1><ul><li>游戏开始</li></ul><p><img src = https://s1.ax1x.com/2022/08/06/vunAA0.png width = 60%></p><ul><li>游戏进行</li></ul><p><img src = https://s1.ax1x.com/2022/08/06/vunF7q.png width = 40%></p><ul><li>游戏结束</li></ul><p><img src = https://s1.ax1x.com/2022/08/06/vunENV.png width = 40%></p><h1 id="（二）README"><a href="#（二）README" class="headerlink" title="（二）README"></a>（二）README</h1><ul><li><p>本游戏玩法和贪吃蛇一致，可以双人 PK ，也可以单人操纵两蛇（推荐），锻炼大脑能力</p></li><li><p>代码面向新手，提供了非常详细的注释，语言平易近人，没有参杂过多“高端操作”，可以作为初学 C 语言的尝试项目（其实我也是初学hhh）</p></li><li><p>欢迎交流代码内容，发现不足，一起进步！</p></li><li><p>这个代码适用于 Windows 环境，如果使用 Mac 环境或 Linux 环境可能需要修改个别代码</p></li><li><p>可以使用 <code>DEV-C++</code> 直接编译运行，如果使用 <code>vscode</code> 编译运行需要将编码格式修改为 <code>Simplified Chinese(GBK)</code> ，用来识别特殊符号。此外无需安装其它库。</p></li></ul><ul><li>转发使用请注明出处，谢谢！</li></ul><h1 id="（三）一些随笔"><a href="#（三）一些随笔" class="headerlink" title="（三）一些随笔"></a>（三）一些随笔</h1><ul><li><p>使用 C 语言 <code>struct</code> 来构造程序，<code>struct</code> 在某些层面和 C++ 的 class 有某些相似性</p></li><li><p>防闪烁方法主要通过调用系统 API ，移动光标在特定位置进行输出实现，效果可观</p></li></ul><h1 id="（四）挖一些坑"><a href="#（四）挖一些坑" class="headerlink" title="（四）挖一些坑"></a>（四）挖一些坑</h1><ul><li><p>后续可能会出一版零基础 C 语言教程：从安装编程软件到写出《double snake》游戏的 3 天速成教程，目的在于采用碎片化叙述知识和任务导引的方式，帮助初学者建立起对于一门语言的“感觉”，不至于一开始就陷入系统冗杂的教材体系。</p></li><li><p>会在《Double Snakes》的基础上开发《Multiple Snakes》，并基于此用 C 语言手敲一遍遗传算法，帮助刚开始学计算机的同学从底层直接感受和理解算法</p></li></ul><h1 id="（五）完整代码"><a href="#（五）完整代码" class="headerlink" title="（五）完整代码"></a>（五）完整代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************头文件和预定义*********************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h_length 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> v_length 50</span></span><br><span class="line"><span class="comment">// 小键盘键位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UP 72    <span class="comment">//方向键：上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOWN 80  <span class="comment">//方向键：下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 75  <span class="comment">//方向键：左</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT 77 <span class="comment">//方向键：右</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE 32 <span class="comment">//暂停</span></span></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************自定义 struct 类型和 enum 类型*********************/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Move_Direction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    up,</span><br><span class="line">    down,</span><br><span class="line">    left,</span><br><span class="line">    right</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Items</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    nothing, <span class="comment">// 空白（表示什么都没有）</span></span><br><span class="line">    wall,</span><br><span class="line">    snakebody0,</span><br><span class="line">    snakebody1,</span><br><span class="line">    snakehead0,</span><br><span class="line">    snakehead1,</span><br><span class="line">    food</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;                             <span class="comment">// id = 0 表示 0 号蛇，id = 1 表示 1 号蛇</span></span><br><span class="line">    <span class="type">int</span> length = <span class="number">4</span>;                     <span class="comment">// 蛇的长度</span></span><br><span class="line">    <span class="type">int</span> body_position[MAX_LENGTH][<span class="number">2</span>];   <span class="comment">// 蛇身体的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Move_Direction</span> <span class="title">move_direction</span>;</span> <span class="comment">// 蛇运动的方向</span></span><br><span class="line">    <span class="type">int</span> isdead = <span class="number">0</span>;                     <span class="comment">// 蛇是否已经死亡</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">snake_move</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************地图和两条蛇的定义*********************/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Items</span> <span class="title">map</span>[<span class="title">v_length</span>][<span class="title">h_length</span>] =</span> &#123;nothing&#125;; <span class="comment">// 相当于全是 nothing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span> <span class="title">snakes</span>[2];</span></span><br><span class="line"><span class="type">int</span> food_position[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> map_choice;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************全局函数声明*************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pretreatment</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">choose_map</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change_direction</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">create_food</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> create_time)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">is_eating_food</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gameover</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************主函数**************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pretreatment();</span><br><span class="line">    welcome();</span><br><span class="line">    <span class="comment">// printf(&quot;hhhhh1&quot;);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        change_direction();</span><br><span class="line">        snakes[<span class="number">0</span>].snake_move();</span><br><span class="line">        snakes[<span class="number">1</span>].snake_move();</span><br><span class="line">        <span class="keyword">if</span> (snakes[<span class="number">0</span>].isdead + snakes[<span class="number">1</span>].isdead)</span><br><span class="line">        &#123;</span><br><span class="line">            gameover();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************全局函数**************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">(<span class="keyword">enum</span> Items item, <span class="type">int</span> row, <span class="type">int</span> column)</span></span><br><span class="line">&#123;</span><br><span class="line">    COORD pos;                                       <span class="comment">//定义光标位置的结构体变量</span></span><br><span class="line">    pos.X = <span class="number">2</span> * column;                              <span class="comment">//横坐标</span></span><br><span class="line">    pos.Y = row;                                     <span class="comment">//纵坐标</span></span><br><span class="line">    HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); <span class="comment">//获取控制台句柄</span></span><br><span class="line">    SetConsoleCursorPosition(handle, pos);           <span class="comment">//设置光标位置</span></span><br><span class="line">    <span class="keyword">switch</span> (item)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> wall:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>); <span class="comment">// 墙体白色</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 第一条蛇是绿色的</span></span><br><span class="line">    <span class="keyword">case</span> snakebody0:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> snakehead0:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 第二条蛇是黄色的</span></span><br><span class="line">    <span class="keyword">case</span> snakebody1:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> snakehead1:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> food:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">4</span>); <span class="comment">// 食物红色</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;★&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> nothing:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>); <span class="comment">// 空气（表示什么都没有）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 ＠＠　　　　 　　　　　　　　＠　　　　　　　　＠　　　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　　　＠＠＠＠　　　　　　　　　　　　　　　　　　  ＠＠　　　　　　　　　　　　　＠　　　　　　　　＠＠　　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　＠＠＠＠＠＠＠＠　　　　　　　　　　　　　　　　＠＠　　　　　　　　　　　　　　＠　　　　　　　　＠＠　　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠＠＠＠＠＠　＠＠＠＠＠＠　　　　　　＠＠＠＠＠　＠＠＠＠＠＠＠＠＠＠＠　　　　　　＠　　　　＠＠＠＠＠＠＠＠＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　＠＠＠＠＠＠　＠＠＠　　＠＠＠＠＠＠　　　　＠＠　　＠　＠＠　　　　　　　　　　　　　　　＠　　　　＠＠　　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　＠＠＠＠＠＠＠＠＠＠＠＠＠＠　　　　　　＠　　　＠＠＠　　　　　　　　　　　　　　＠＠＠  ＠＠　＠　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　　　　　　　＠＠＠＠　　　　　　　＠　　　＠　＠＠＠＠＠＠＠＠＠　　　　　　＠　＠　　＠　＠　＠　　　＠＠＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　＠＠＠＠＠＠＠＠＠　　　　　　　　＠　　　＠　　　　　　　＠＠＠　　　　　　＠　＠　　＠　＠　＠　　　＠＠＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　＠＠＠＠＠　　　　　　　　　　　　＠　　　＠　　　　　　＠＠＠　　　　　　　＠　＠　　＠　　　＠　　＠＠＠　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠＠＠＠＠＠＠＠＠＠＠＠　　　　　　　＠　　　＠　　　　　＠＠＠　　　　　　　　＠　＠　　＠　　　＠　＠＠＠　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠＠　　　＠　　　　＠＠　　　　　　　＠　　　＠　　　　＠＠＠　　　　　　　　　＠＠＠　　＠　　　＠＠＠＠　　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠　　　　＠　　　　　＠　　　　　　　＠　　　＠　　　＠＠＠　　　　　　　　　　＠＠＠＠＠＠　　　＠＠＠　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠　　　＠＠　　　　　＠　　　　　　　＠　　　＠　　＠＠＠　　　　　＠＠　　　　　　＠　　＠　　　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠　　　＠＠　＠＠　　＠　　　　　　　＠　　　＠　＠＠＠　　　　　　＠＠　　　　　　＠　　＠＠　　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠　　＠＠＠　＠＠＠＠＠　　　　　　　＠　　　＠　＠＠　　　　　　　＠＠　　　　　　＠　＠＠＠　　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　＠＠＠　　　＠＠＠＠　　　　　　　＠＠　＠＠　＠＠　　　　　　　＠＠　　　＠＠＠＠＠＠＠＠＠　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　＠＠＠＠＠＠　　　　　　＠＠＠　　　　　　＠＠＠＠＠　＠＠＠＠＠＠＠＠＠＠＠　　　＠＠＠＠＠　　＠＠　＠＠　　　＠＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　＠＠＠＠　　　　　　　　　＠＠　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　＠＠＠＠＠＠＠　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n请按 enter 继续，祝您游戏愉快！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (getch() != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎进入贪吃蛇游戏！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏规则如下：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用键盘上的 W、A、S、D 键分别可以使蛇向上下左右移动\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请让您的蛇尽量多地吃到食物并避免触碰到自身和墙壁\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;水平方向的墙面长度被设置为%d,\n竖直方向的墙面长度被设置为%d。\n&quot;</span>, h_length, v_length); <span class="comment">// 重复信息，向玩家确认</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n现在您可以选择一张地图\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0：正常模式\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1：隔离模式墙模式\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2：随机散点墙模式\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3：固定纵横墙模式\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4：随机水平墙模式\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入 0~4 中的其中一个数字：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;map_choice);</span><br><span class="line">        <span class="keyword">if</span> (map_choice &gt;= <span class="number">0</span> &amp;&amp; map_choice &lt;= <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按 enter 继续，祝您游戏愉快！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (getch() != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;请输入地图的水平和竖直尺寸（两个数字中间用空格隔开）：\n&quot;);</span></span><br><span class="line">    <span class="comment">// scanf(&quot;%d %d&quot;, &amp;h_length, &amp;v_length);</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pretreatment</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;title Double Snakes&quot;</span>);         <span class="comment">// 设置cmd窗口的名字</span></span><br><span class="line">    system(<span class="string">&quot;mode con cols=200 lines=100&quot;</span>); <span class="comment">// 设置cmd窗口的大小</span></span><br><span class="line"></span><br><span class="line">    CONSOLE_CURSOR_INFO curInfo;                     <span class="comment">// 定义光标信息的结构体变量</span></span><br><span class="line">    curInfo.dwSize = <span class="number">1</span>;                              <span class="comment">// 如果没赋值的话，光标隐藏无效</span></span><br><span class="line">    curInfo.bVisible = FALSE;                        <span class="comment">// 将光标设置为不可见</span></span><br><span class="line">    HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); <span class="comment">// 获取控制台句柄</span></span><br><span class="line">    SetConsoleCursorInfo(handle, &amp;curInfo);          <span class="comment">// 设置光标信息</span></span><br><span class="line"></span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>)); <span class="comment">// 随机数播种</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">choose_map</span><span class="params">(<span class="type">int</span> map_choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">switch</span> (map_choice)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 没有任何模式</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 隔离模式</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= v_length - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[i][h_length / <span class="number">2</span>] = wall;</span><br><span class="line">            myprintf(wall, i, h_length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机生成墙模式</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// -8 是为了让行列值尽量靠中</span></span><br><span class="line">            <span class="type">int</span> row = rand() % (v_length - <span class="number">4</span>);</span><br><span class="line">            <span class="type">int</span> column = rand() % (h_length - <span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 如果map[row][column] + map[row - 1][column] + map[row + 1][column] + map[row][column - 1] + map[row][column + 1] == 0那么就是这几个位置都是 nothing</span></span><br><span class="line">            <span class="keyword">if</span> (!(<span class="built_in">map</span>[row][column] + <span class="built_in">map</span>[row - <span class="number">1</span>][column] + <span class="built_in">map</span>[row + <span class="number">1</span>][column] + <span class="built_in">map</span>[row][column - <span class="number">1</span>] + <span class="built_in">map</span>[row][column + <span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[row][column] = wall;</span><br><span class="line">                myprintf(wall, row, column);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">// 竖直固定墙模式</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= v_length / <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>[i][h_length / <span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][h_length / <span class="number">2</span>] = wall;</span><br><span class="line">                myprintf(wall, i, h_length / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = v_length - v_length / <span class="number">3</span> - <span class="number">1</span>; i &lt;= v_length - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>[i][h_length / <span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][h_length / <span class="number">2</span>] = wall;</span><br><span class="line">                myprintf(wall, i, h_length / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= h_length / <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">map</span>[v_length / <span class="number">2</span>][i] = wall;</span><br><span class="line">            myprintf(wall, v_length / <span class="number">2</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = h_length - h_length / <span class="number">3</span> - <span class="number">1</span>; i &lt;= h_length - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[v_length / <span class="number">2</span>][i] = wall;</span><br><span class="line">            myprintf(wall, v_length / <span class="number">2</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="comment">// 随机水平墙模式</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> row = rand() % (v_length - <span class="number">6</span> * i) + <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> column = rand() % (h_length - <span class="number">12</span>) + <span class="number">6</span>;</span><br><span class="line">            <span class="type">int</span> wall_length = rand() % <span class="number">15</span> + <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= wall_length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">map</span>[row][column + j] &amp;&amp; column + j &lt;= h_length - <span class="number">2</span>) <span class="comment">// 如果map[row][column + j] 不为 nothing</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">map</span>[row][column + j] = wall;</span><br><span class="line">                    myprintf(wall, row, column + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信息函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化一些信息</span></span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">// 定义循环变量 i，j</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化两条蛇的id</span></span><br><span class="line">    snakes[<span class="number">0</span>].id = <span class="number">0</span>;</span><br><span class="line">    snakes[<span class="number">1</span>].id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将最上方的墙保存到数组当中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= h_length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">0</span>][i] = wall; <span class="comment">// 最上方的墙位于第 0 行，因此第一维下标都是 0</span></span><br><span class="line">        myprintf(wall, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为第 0 行和第 v_length 行已经用来创建上下两面墙，因此我们的对于二维数组行数的循环范围应该扣去首尾两行，即 1 到 v_length - 2</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= v_length - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 刻画左右两面墙，这两句代码会被重复 v_length - 1 次，最终组成两面连续的墙</span></span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">0</span>] = wall;            <span class="comment">// 左边的竖直墙</span></span><br><span class="line">        <span class="built_in">map</span>[i][h_length - <span class="number">1</span>] = wall; <span class="comment">// 右边的竖直墙</span></span><br><span class="line">        myprintf(wall, i, <span class="number">0</span>);</span><br><span class="line">        myprintf(wall, i, h_length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后将最下方的墙保存到数组当中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= h_length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[v_length - <span class="number">1</span>][i] = wall;     <span class="comment">// 最下方的墙位于第 v_length - 1 行，因此第一维下标都是  v_length - 1</span></span><br><span class="line">        myprintf(wall, v_length - <span class="number">1</span>, i); <span class="comment">// 打印最下方的墙</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置蛇的初始位置信息</span></span><br><span class="line">    <span class="comment">// 第一条蛇位于地图左上方</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= snakes[<span class="number">0</span>].length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        snakes[<span class="number">0</span>].body_position[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        snakes[<span class="number">0</span>].body_position[i][<span class="number">1</span>] = <span class="number">4</span> - i;</span><br><span class="line">        <span class="comment">// 蛇头在1行4列；蛇尾在1行1列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二条蛇位于地图右下方</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= snakes[<span class="number">0</span>].length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        snakes[<span class="number">1</span>].body_position[i][<span class="number">0</span>] = v_length - <span class="number">2</span>;</span><br><span class="line">        snakes[<span class="number">1</span>].body_position[i][<span class="number">1</span>] = h_length - <span class="number">5</span> + i;</span><br><span class="line">        <span class="comment">// 蛇头在v_length - 2行、h_length - 5列; 蛇尾在v_length - 2行，h_length - 2列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>[snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">0</span>]][snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">1</span>]] = snakehead0;     <span class="comment">// 在地图上记录 0 号蛇的蛇头</span></span><br><span class="line">    myprintf(snakehead0, snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">0</span>], snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 在屏幕上绘制 0 号蛇的蛇头</span></span><br><span class="line">    <span class="built_in">map</span>[snakes[<span class="number">1</span>].body_position[<span class="number">0</span>][<span class="number">0</span>]][snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">1</span>]] = snakehead1;     <span class="comment">// 在地图上记录 1 号蛇的蛇头</span></span><br><span class="line">    myprintf(snakehead1, snakes[<span class="number">1</span>].body_position[<span class="number">0</span>][<span class="number">0</span>], snakes[<span class="number">1</span>].body_position[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 在屏幕上绘制 1 号蛇的蛇头</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= snakes[<span class="number">0</span>].length - <span class="number">1</span>; i++)                                         <span class="comment">// 由于初始状态下 1 号蛇的长度和 0 号蛇的长度是相等的，所以这边 snakes[0].length - 1 就是 snakes[1].length - 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[snakes[<span class="number">0</span>].body_position[i][<span class="number">0</span>]][snakes[<span class="number">0</span>].body_position[i][<span class="number">1</span>]] = snakebody0;     <span class="comment">// 在地图上记录 0 号蛇的蛇身</span></span><br><span class="line">        myprintf(snakebody0, snakes[<span class="number">0</span>].body_position[i][<span class="number">0</span>], snakes[<span class="number">0</span>].body_position[i][<span class="number">1</span>]); <span class="comment">// 在屏幕上绘制 0 号蛇的蛇身</span></span><br><span class="line">        <span class="built_in">map</span>[snakes[<span class="number">1</span>].body_position[i][<span class="number">0</span>]][snakes[<span class="number">1</span>].body_position[i][<span class="number">1</span>]] = snakebody1;     <span class="comment">// 在地图上记录 1 号蛇的蛇身</span></span><br><span class="line">        myprintf(snakebody1, snakes[<span class="number">1</span>].body_position[i][<span class="number">0</span>], snakes[<span class="number">1</span>].body_position[i][<span class="number">1</span>]); <span class="comment">// 在屏幕上绘制 0 号蛇的蛇身</span></span><br><span class="line">    &#125;</span><br><span class="line">    snakes[<span class="number">0</span>].move_direction = right; <span class="comment">// 0 号蛇向右运动</span></span><br><span class="line">    snakes[<span class="number">1</span>].move_direction = left;  <span class="comment">// 1 号蛇向左运动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建地图</span></span><br><span class="line">    choose_map(map_choice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 3 个食物</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        create_food(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_direction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (kbhit()) <span class="comment">// 如果缓冲区中还有</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (getch())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">0</span>].move_direction != down)</span><br><span class="line">                snakes[<span class="number">0</span>].move_direction = up;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">0</span>].move_direction != up)</span><br><span class="line">                snakes[<span class="number">0</span>].move_direction = down;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">0</span>].move_direction != right)</span><br><span class="line">                snakes[<span class="number">0</span>].move_direction = left;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">0</span>].move_direction != left)</span><br><span class="line">                snakes[<span class="number">0</span>].move_direction = right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UP:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">1</span>].move_direction != down)</span><br><span class="line">                snakes[<span class="number">1</span>].move_direction = up;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DOWN:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">1</span>].move_direction != up)</span><br><span class="line">                snakes[<span class="number">1</span>].move_direction = down;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">1</span>].move_direction != right)</span><br><span class="line">                snakes[<span class="number">1</span>].move_direction = left;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">1</span>].move_direction != left)</span><br><span class="line">                snakes[<span class="number">1</span>].move_direction = right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SPACE:</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_food</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> create_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (create_time == <span class="number">10000</span>) <span class="comment">// 超过 10000 次仍然不能得到食物</span></span><br><span class="line">    &#123;</span><br><span class="line">        food_position[i][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        food_position[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;                                                             <span class="comment">// 随机数播种</span></span><br><span class="line">    food_position[i][<span class="number">0</span>] = rand() % v_length;                      <span class="comment">// 随机生成行数</span></span><br><span class="line">    food_position[i][<span class="number">1</span>] = rand() % h_length;                      <span class="comment">// 随机生成列数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[food_position[i][<span class="number">0</span>]][food_position[i][<span class="number">1</span>]] == nothing) <span class="comment">// 只有在空地上才能产生食物</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[food_position[i][<span class="number">0</span>]][food_position[i][<span class="number">1</span>]] = food;     <span class="comment">// 在地图上更新食物信息</span></span><br><span class="line">        myprintf(food, food_position[i][<span class="number">0</span>], food_position[i][<span class="number">1</span>]); <span class="comment">// 绘制出食物食物</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        create_food(i, create_time + <span class="number">1</span>); <span class="comment">// 递归，再创建一次食物</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_eating_food</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (food_position[i][<span class="number">0</span>] == row &amp;&amp; food_position[i][<span class="number">1</span>] == column) <span class="comment">// 只要满足吃掉的是其中一个食物</span></span><br><span class="line">        &#123;</span><br><span class="line">            create_food(i, <span class="number">0</span>); <span class="comment">// 再创建一个食物</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gameover</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Sleep(<span class="number">1000</span>); <span class="comment">// 反应时间</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                       ＠＠＠＠                           \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;     　　　　　　　　　  ＠＠＠　　　　　　　　　　　　       \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　 　　　　　   　　　　＠＠＠　　　　　　　　　　　　        \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　 　　＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      ＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠        \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;     ＠＠＠                                 ＠＠＠         \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    ＠＠＠            ＠＠＠＠              ＠＠＠          \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                     ＠＠＠＠                              \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        ＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                    ＠＠＠＠                                \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 ＠＠＠  ＠＠＠                             \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;               ＠＠＠＠   ＠＠＠＠                          \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;             ＠＠＠        ＠＠＠＠                         \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠    \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                  ＠＠＠＠                 \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠＠＠＠＠＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠　　　  ＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠　　　  ＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠　　　  ＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠＠＠＠＠＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                   ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                   ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                          ＠      ＠＠＠                   \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                           ＠＠  ＠＠＠                     \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                            ＠＠＠＠＠                      \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                              ＠＠＠                       \n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏结束，请按 enter 继续！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (getch() != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 0 条蛇的最终长度是 %d\n&quot;</span>, snakes[<span class="number">0</span>].length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 1 条蛇的最终长度是 %d\n&quot;</span>, snakes[<span class="number">1</span>].length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按 enter 退出\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (getch() != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************结构体内部函数**************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Snake::snake_move</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">// 定义循环变量 i，j</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置在这个函数中应该使用哪种绘制蛇的材质</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Items</span> <span class="title">temphead</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Items</span> <span class="title">tempbody</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (this-&gt;id)</span><br><span class="line">    &#123;</span><br><span class="line">        temphead = snakehead1;</span><br><span class="line">        tempbody = snakebody1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        temphead = snakehead0;</span><br><span class="line">        tempbody = snakebody0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> move[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 移动方向数组：由四个一维数组组成，分别代表向上下左右运动</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temptail[<span class="number">2</span>] = &#123;this-&gt;body_position[this-&gt;length - <span class="number">1</span>][<span class="number">0</span>], this-&gt;body_position[this-&gt;length - <span class="number">1</span>][<span class="number">1</span>]&#125;; <span class="comment">// 创建一个数组用来存放蛇尾所在位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将后面所有身体段向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (i = this-&gt;length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把前一位的位置赋给后一位</span></span><br><span class="line">        this-&gt;body_position[i][<span class="number">0</span>] = this-&gt;body_position[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        this-&gt;body_position[i][<span class="number">1</span>] = this-&gt;body_position[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    myprintf(tempbody, this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>], this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 将原本蛇头的位置打印为蛇身</span></span><br><span class="line">    <span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] = tempbody;     <span class="comment">// 在地图上相应地进行更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将蛇头依据方向进行移动</span></span><br><span class="line">    this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>] += move[this-&gt;move_direction][<span class="number">0</span>];</span><br><span class="line">    this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>] += move[this-&gt;move_direction][<span class="number">1</span>];</span><br><span class="line">    myprintf(temphead, this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>], this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 打印新的蛇头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果碰壁或碰到身体设置蛇已经死亡</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] == wall || <span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] == snakebody0 || <span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] == snakebody1)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;isdead = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] = temphead; <span class="comment">// 在地图上相应地进行更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果吃到食物设置蛇变长</span></span><br><span class="line">    <span class="keyword">if</span> (is_eating_food(this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>], this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>])) <span class="comment">// 蛇头的位置是否在食物的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 由于尾部在地图上和画面上尾部的位置都还没有去除，因此也不必更改</span></span><br><span class="line">        this-&gt;length++;</span><br><span class="line">        this-&gt;body_position[this-&gt;length - <span class="number">1</span>][<span class="number">0</span>] = temptail[<span class="number">0</span>];</span><br><span class="line">        this-&gt;body_position[this-&gt;length - <span class="number">1</span>][<span class="number">1</span>] = temptail[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果没吃到食物就将尾部清除</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在蛇的位置信息 body_positiong 中已经清除</span></span><br><span class="line">        myprintf(nothing, temptail[<span class="number">0</span>], temptail[<span class="number">1</span>]); <span class="comment">// 在画面上清除尾部</span></span><br><span class="line">        <span class="built_in">map</span>[temptail[<span class="number">0</span>]][temptail[<span class="number">1</span>]] = nothing;     <span class="comment">// 在地图信息上清除尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛 TOPSIS 优劣解距离算法</title>
      <link href="/2022/08/10/TOPSIS%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/10/TOPSIS%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）GUIDANCE"><a href="#（一）GUIDANCE" class="headerlink" title="（一）GUIDANCE"></a>（一）GUIDANCE</h1><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>全称 “Technique for Order Preference by Similarity to Ideal Solution”，即“逼近理想解排序法”</p><p>该算法主要用于解决评价类问题，用于确定各个方案层的最终得分</p><p>优点在于能充分利用原始数据的信息， 其结果能精确地反映各评价方案之间的差距。</p><p>TOPSIS 和 AHP 的主要差异在于相关功能和适用问题范围的差异</p><ul><li>TOPSIS 更加适用于解决原始数据相当充分几乎可以进行定量分析的情景</li><li>AHP 算法更加适用于已知条件较为模糊和复杂，难于完全定量分析的情景</li></ul><blockquote><p>事实上，优劣解距离算法和层次分析法可以结合</p></blockquote><h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><p>TOPSIS 的核心原理主要是“指标正向化”方法与“标准化消除量纲影响”方法两个方法的合理性，事实上，这两个方法也是 TOPSIS 和 AHP 的主要区别</p><p>幸运的是，这两个方法的合理性并不需要我们长篇大论地证明，只需要我们使用合理的语言在使用时稍加阐述即可，严格的证明已经由运筹学家解决</p><h1 id="（二）模型步骤"><a href="#（二）模型步骤" class="headerlink" title="（二）模型步骤"></a>（二）模型步骤</h1><h2 id="将明确获取的指标整合成表格"><a href="#将明确获取的指标整合成表格" class="headerlink" title="将明确获取的指标整合成表格"></a>将明确获取的指标整合成表格</h2><p>我们依然采用层次分析法的例子，不同的是，这次，我们的所有要素都有非常准确的数据来源（假设这些数据都已经被我们获取）</p><ul><li>“健康指数”数据由相关专业研究人员评定</li><li>“价格”数据是以人民币为单位的绝对数值</li><li>“距离”数据经过精确测量得到</li><li>“咸淡程度”数据由食物含盐量精确测定</li><li>“等待时间”数据由RUC小喇叭上学生反馈的平均等待时间确定</li></ul><p>将这些信息整理成表格如下：</p><div class="table-container"><table><thead><tr><th>餐厅名称</th><th>餐厅得分(待求值)</th><th>价格</th><th>健康指数</th><th>距离</th><th>咸淡程度</th><th>等待时间</th></tr></thead><tbody><tr><td>东区二楼</td><td></td><td>16</td><td>90</td><td>1.31</td><td>53</td><td>5.21</td></tr><tr><td>西区一楼</td><td></td><td>10</td><td>83</td><td>0.45</td><td>66</td><td>3.45</td></tr><tr><td>中区二楼</td><td></td><td>13</td><td>83</td><td>1.34</td><td>34</td><td>4.03</td></tr></tbody></table></div><h2 id="对表格中的数据进行正向化处理"><a href="#对表格中的数据进行正向化处理" class="headerlink" title="对表格中的数据进行正向化处理"></a>对表格中的数据进行正向化处理</h2><p>我们发现表格中的数据并不完全是同一类型的数据</p><p>事实上，TOPSIS 中用到的数据可以被我们分为四种：</p><ul><li>极大型指标：指标越大越好</li><li>极小型指标：指标越小越好</li><li>中间型指标：指标越接近某个值越好</li><li>区间型指标：指标处在某个区间内最好，区间外的越靠近这个区间越好</li></ul><blockquote><p>比如上面的例子，健康指数是极大型指标，价格、距离和等待时间是极小型指标，而咸淡程度则是区间型数据</p></blockquote><p>下面，我们给出统一指标类型的方法——将所有指标都转成极大型指标，即正向化处理</p><ol><li>对于极小型指标</li></ol><p>找出这组数据的最大值 $x_{max}$ ，每个数据 $x_i$ 对应的正向化以后的指标就是 $x_{max} - x_i$</p><ol><li>对于中间型指标</li></ol><p>列出这组数据和中间型指标的差值，这个差值就是一组极小型指标，采用 1 中的处理方法进行类似的处理，最后做一步<strong>区间赋分处理</strong></p><p>假设正向化处理的函数为 <code>positiveChange</code>，则处理的公式为：</p><script type="math/tex; mode=display">    d_{max} = max\{|x_i - x_{best}|\},\forall i = 1,2,\dots ,n</script><script type="math/tex; mode=display">     positiveChange(x) =  \frac{d_{max} - |x-x_{best}|}{d_{max}}</script><ol><li>对于区间型指标</li></ol><p>如果数据处于区间内，则直接赋予最大值，即 1</p><p>如果数据位于区间外，则计算数据和区间边界的距离</p><p>设区间为 $[a,b]$ ，我们将计算过程分成下面的几步：</p><ul><li>求出所有数据和区间边界的最大距离 $d_{max}$</li></ul><script type="math/tex; mode=display">d_{max} = max(a - min\{x_i\},max\{x_i\}-b),\forall i = 1,2,\dots,n</script><ul><li>求出每点和区间边界的距离 <code>d(x)</code>，代入公式计，假设正向化处理的函数为 <code>positiveChange</code></li></ul><script type="math/tex; mode=display">    d(x) =     \begin{cases}    a - x,\quad x < a\\    x - b, \quad x > b    \end{cases}</script><script type="math/tex; mode=display">    positiveChange(x) =     \begin{cases}    1,\quad x \in [a, b]\\    \frac{d_{max} - d(x)}{d_{max}}, \quad x \notin [a,b]    \end{cases}</script><h2 id="对表格中的数据进行标准化处理"><a href="#对表格中的数据进行标准化处理" class="headerlink" title="对表格中的数据进行标准化处理"></a>对表格中的数据进行标准化处理</h2><p>在进行正向化处理之后，我们得到了增长意义统一（类型）的一组数据</p><p>然而，在统一意义之后，还应该进行统一的是单位：对于单位我们采用标准化处理的统一方法</p><p>标准化方法是，假设方案 $1,2,3,\dots,n$ 的在同一个因素评价得分分别是 $a_1,a_2,\dots,a_n$</p><p>那么进行标准化以后他们的得分变为 $b_1,b_2,\dots,b_n$ ，应该满足：</p><script type="math/tex; mode=display">b_i = \frac{a_i}{\sqrt{\sum_{k=1}^na_k^2}}</script><p>首先我们将表格数据罗列成正向化矩阵，其中同一列表示同一因素评价下各方案的得分，同一行表示同一方案下不同因素的得分情况，假设一共有 $m$ 个因素和 $n$ 个方案，则</p><p>假设原矩阵（正向化后）为：</p><script type="math/tex; mode=display">\begin{pmatrix}    x_{11}&x_{12}&\cdots&x_{1m}\\    x_{21}&x_{22}&\cdots&x_{2m}\\    \vdots&\vdots&\ddots&\vdots\\    x_{n1}&x_{n2}&\cdots&x_{nm}\end{pmatrix}</script><p>将这个矩阵进行标准化后为：</p><script type="math/tex; mode=display">\begin{pmatrix}    z_{11}&z_{12}&\cdots&z_{1m}\\    z_{21}&z_{22}&\cdots&z_{2m}\\    \vdots&\vdots&\ddots&\vdots\\    z_{n1}&z_{n2}&\cdots&z_{nm}\end{pmatrix}</script><p>同理应该满足$z_{ij} = \frac{x_{ij}}{\sqrt{\sum_{i=1}^nx_{ij}^2}} , \forall j = 1,2,\dots,m$</p><h2 id="对不同指标赋予一定的权重（可选）"><a href="#对不同指标赋予一定的权重（可选）" class="headerlink" title="对不同指标赋予一定的权重（可选）"></a>对不同指标赋予一定的权重（可选）</h2><p>我们还可以使用层次分析法对不同权重的重要程度作出分析，具体参见 <code>AHP.md</code> ， 假设已经通过分析得到这些要素的权重分别为 $w_1,w_2,\dots,w_m$</p><h2 id="根据指标权重和表格数据给出最终得分"><a href="#根据指标权重和表格数据给出最终得分" class="headerlink" title="根据指标权重和表格数据给出最终得分"></a>根据指标权重和表格数据给出最终得分</h2><p>经过上述过程，我们现在已经得到了标准化后的矩阵了，即</p><script type="math/tex; mode=display">\begin{pmatrix}    z_{11}&z_{12}&\cdots&z_{1m}\\    z_{21}&z_{22}&\cdots&z_{2m}\\    \vdots&\vdots&\ddots&\vdots\\    z_{n1}&z_{n2}&\cdots&z_{nm}\end{pmatrix}</script><p>现在我们还要经过一步处理得到最终的得分，在列出公式之前还是应该提醒一下：</p><p>同一列表示同一因素评价下各方案的得分，同一行表示同一方案下不同因素的得分情况，假设一共有 $m$ 个因素和 $n$ 个方案</p><p>我们整合出一个最大值向量：它包含了 $m$ 个分量，表示这 $m$ 个因素的最大指标，即：</p><script type="math/tex; mode=display">    Z^{max} = (\underbrace{max\{z_{11},z_{21},\cdots,z_{n1}\},max\{z_{12},z_{22},\cdots,z_{n2}\},\cdots,max\{z_{1m},z_{2m},\cdots,z_{nm}\}}_{共 m 个分量})</script><p>同理，我们也可以定义最小值向量</p><script type="math/tex; mode=display">    Z^{min} = (\underbrace{min\{z_{11},z_{21},\cdots,z_{n1}\},min\{z_{12},z_{22},\cdots,z_{n2}\},\cdots,min\{z_{1m},z_{2m},\cdots,z_{nm}\}}_{共 m 个分量})</script><p>我们知道任意一行向量表示一个方案的所有因素的得分</p><p>第 $i$ 个方案对应的行向量（各因素得分）为 $z_{i1},z_{i2},\cdots,z_{im}$，我们可以定义这个方案和最大值向量的距离</p><script type="math/tex; mode=display">    D^{from-max}_i = \sqrt{\sum^{m}_{j=1}(Z^{max}_j-z_{ij})^m} \quad,\quad \forall i = 1,2,\cdots,n</script><p>同理我们也可以定义这个方案对应的行向量（各因素得分）和最小值向量的距离</p><script type="math/tex; mode=display">    D^{from-min}_i = \sqrt{\sum^{m}_{j=1}(Z^{min}_j-z_{ij})^m} \quad,\quad \forall i = 1,2,\cdots,n</script><blockquote><p>值得注意的是，我们上面两个公式的计算是默认每个因素之间重要程度的比值为 $w_1:w_2:\cdots:w_n = 1:1:\cdots :1$ 的，如果我们根据一些方法（如 AHP 、熵权法 etc.）得到了不同因素的权重，那么上面两个公式应该改成：</p><script type="math/tex; mode=display">D^{from-max}_i = \sqrt{\sum^{m}_{j=1}w_j(Z^{max}_j-z_{ij})^m} \quad,\quad \forall i = 1,2,\cdots,n</script><script type="math/tex; mode=display">D^{from-min}_i = \sqrt{\sum^{m}_{j=1}w_j(Z^{min}_j-z_{ij})^m} \quad,\quad \forall i = 1,2,\cdots,n</script></blockquote><p>这样，我们可以计算出这个方案的得分，设第 $i$ 行对应的方案的得分为 $s_i$，应该有</p><script type="math/tex; mode=display">    s_i = \frac{D^{from-min}_i}{D^{from-min}_i+D^{from-max}_i}</script><p>可以用下面的图表示</p><center><img src = https://s1.ax1x.com/2022/08/08/vQpGDK.png width = 55%></center><p>使用和层次分析法一样的归一化方法，即可得到最终得分，进而得到最终排名</p><h2 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h2><ol><li>将明确获取的指标整合成表格（行是方案，列是因素）</li><li>对表格中的数据进行正向化处理</li><li>对表格中的数据进行标准化处理（统一单位）</li><li>对不同指标赋予一定的权重（可选）</li><li>根据指标权重和表格数据给出最终得分</li></ol><h1 id="（三）代码实现"><a href="#（三）代码实现" class="headerlink" title="（三）代码实现"></a>（三）代码实现</h1><blockquote><p>以下代码可以在我的 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm/TOPSIS%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95">GitHub 仓库</a> 中下载</p></blockquote><ul><li>主代码部分</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">clc, clear;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第一步：读取矩阵的内容</span></span><br><span class="line">data <span class="built_in">=</span> readmatrix(<span class="string">&#x27;TOPSIS.xls&#x27;</span>);</span><br><span class="line">[n,m] <span class="built_in">=</span> size(data);</span><br><span class="line">disp([<span class="string">&#x27;您一共输入了 &#x27;</span>, num2str(n), <span class="string">&#x27; 个待评价对象, &#x27;</span>, <span class="string">&#x27;一共有 &#x27;</span>, num2str(m),<span class="string">&#x27; 个评价因素&#x27;</span>]);</span><br><span class="line">needToPositiveChange <span class="built_in">=</span> input([<span class="string">&#x27;这 &#x27;</span>,num2str(m),<span class="string">&#x27; 个因素是否需要先经过正向化处理，需要请输入1，不需要请输入0：&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第二步：对需要进行正向化的列进行正向化</span></span><br><span class="line"><span class="built_in">if</span> needToPositiveChange <span class="built_in">=</span><span class="built_in">=</span> <span class="number">1</span>   <span class="comment">% 表示需要正向化</span></span><br><span class="line">    pos <span class="built_in">=</span> input([<span class="string">&#x27;请以数组的形式输入需要正向化处理的因素所在的列，例如第1，2，3列需要处理，就输入[1,2,3]：&#x27;</span>]);</span><br><span class="line">    PositiveChangeType <span class="built_in">=</span> input(<span class="string">&#x27;请以数组形式依次输入需要处理的这些列的指标类型（1：极小型；2：中间型；3：极大型）：&#x27;</span>);</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span>:size(pos,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% PositiveChange 是我们自定义的一个函数</span></span><br><span class="line">        <span class="comment">% 第一个参数接受一个数组，代表一个因素下的所有方案的评分</span></span><br><span class="line">        <span class="comment">% 第二个参数接受一个数，代表一个因素的指标类型</span></span><br><span class="line">        <span class="comment">% 第三个参数接受一个数，代表这个因素在原始矩阵中的列数</span></span><br><span class="line">        data(:,pos(i)) <span class="built_in">=</span> PositiveChange(data(:,pos(i)), PositiveChangeType(i), pos(i));  <span class="comment">% 将原始矩阵的相列进行正向化</span></span><br><span class="line">    end</span><br><span class="line">    disp(<span class="string">&#x27;正向化后的矩阵为：&#x27;</span>);</span><br><span class="line">    disp(data);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：将正向化后的矩阵标准化</span></span><br><span class="line"><span class="comment">% repmat 函数用于将数组等价拷贝 n 次构成矩阵</span></span><br><span class="line">standard_data <span class="built_in">=</span> data./repmat(sum(data .* data).^<span class="number">0.5</span> , n, <span class="number">1</span>);</span><br><span class="line">disp(<span class="string">&#x27;标准化后的矩阵为：&#x27;</span>);</span><br><span class="line">disp(standard_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：分别计算出和最大向量与最小向量之间的距离，得出评分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面一行代码求出各方案和最大值向量之间的距离</span></span><br><span class="line">d_from_max <span class="built_in">=</span> sum([(standard_data - repmat(max(standard_data), n, <span class="number">1</span>)) .^ <span class="number">2</span>], <span class="number">2</span>) .^ <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% 下面一行代码求出各方案和最小值向量之间的距离</span></span><br><span class="line">d_from_min <span class="built_in">=</span> sum([(standard_data - repmat(min(standard_data), n, <span class="number">1</span>)) .^ <span class="number">2</span>], <span class="number">2</span>) .^ <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% 计算出得分</span></span><br><span class="line">scores <span class="built_in">=</span> d_from_min ./ (d_from_min + d_from_max);</span><br><span class="line"><span class="comment">% 进行归一化</span></span><br><span class="line">standard_scores <span class="built_in">=</span> scores / sum(scores);</span><br><span class="line"><span class="comment">% 降序排序，得到索引</span></span><br><span class="line">[sorted_standard_scores, scores_index] <span class="built_in">=</span> sort(standard_scores, <span class="string">&#x27;descend&#x27;</span>);</span><br><span class="line"></span><br><span class="line">disp(<span class="string">&#x27;最后的得分如下：&#x27;</span>);</span><br><span class="line">disp(standard_scores); <span class="comment">% 显示得分</span></span><br><span class="line">disp(<span class="string">&#x27;排名索引如下：&#x27;</span>);</span><br><span class="line">disp(scores_index);</span><br></pre></td></tr></table></figure><ul><li>正向化转换函数  <code>PositiveChange</code> 函数代码</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function [changed_data] <span class="built_in">=</span> PositiveChange(data, <span class="keyword">type</span>, pos)</span><br><span class="line">    <span class="built_in">if</span> <span class="keyword">type</span> <span class="built_in">=</span><span class="built_in">=</span> <span class="number">1</span></span><br><span class="line">       disp(<span class="string">&#x27;您输入的第 &#x27;</span>, num2str(pos), <span class="string">&#x27; 列是极小型&#x27;</span>);</span><br><span class="line">       changed_data <span class="built_in">=</span> max(data) - data;</span><br><span class="line">       disp(<span class="string">&#x27;----------------------------------------------------------&#x27;</span>);</span><br><span class="line">    elseif <span class="keyword">type</span> <span class="built_in">=</span><span class="built_in">=</span> <span class="number">2</span></span><br><span class="line">       disp(<span class="string">&#x27;您输入的第 &#x27;</span>, num2str(pos), <span class="string">&#x27; 列是中间型&#x27;</span>);</span><br><span class="line">       best <span class="built_in">=</span> input(<span class="string">&#x27;请输入它的最优值：&#x27;</span>);</span><br><span class="line">       maxD_from_best <span class="built_in">=</span> max(abs(data - best));</span><br><span class="line">       changed_data <span class="built_in">=</span> <span class="number">1</span> - abs(data - best)/maxD_from_best;</span><br><span class="line">       disp(<span class="string">&#x27;----------------------------------------------------------&#x27;</span>);</span><br><span class="line">    elseif <span class="keyword">type</span> <span class="built_in">=</span><span class="built_in">=</span> <span class="number">3</span></span><br><span class="line">       disp(<span class="string">&#x27;您输入的第 &#x27;</span>, num2str(pos), <span class="string">&#x27; 列是区间型&#x27;</span>);</span><br><span class="line">       low <span class="built_in">=</span> input(<span class="string">&#x27;请输出区间的下界&#x27;</span>);</span><br><span class="line">       high <span class="built_in">=</span> input(<span class="string">&#x27;请输出区间的上界&#x27;</span>);</span><br><span class="line">       maxD_from_inter <span class="built_in">=</span> max([low - min(data), max(data) - high]);</span><br><span class="line">       datasize <span class="built_in">=</span> size(data, <span class="number">1</span>);</span><br><span class="line">       changed_data <span class="built_in">=</span> zeros(datasize, <span class="number">1</span>);</span><br><span class="line">       for i <span class="built_in">=</span> <span class="number">1</span>:datasize</span><br><span class="line">           <span class="built_in">if</span> data(i) &lt; low</span><br><span class="line">               changed_data(i) <span class="built_in">=</span> <span class="number">1</span> - (low - data(i))/maxD_from_inter;</span><br><span class="line">           elseif data(i) &gt; high</span><br><span class="line">               changed_data(i) <span class="built_in">=</span> <span class="number">1</span> - (data(i) - high)/maxD_from_inter;</span><br><span class="line">           <span class="built_in">else</span></span><br><span class="line">               changed_data(i) <span class="built_in">=</span> <span class="number">1</span>;</span><br><span class="line">           end</span><br><span class="line">       end</span><br><span class="line">       disp(<span class="string">&#x27;----------------------------------------------------------&#x27;</span>);</span><br><span class="line">    <span class="built_in">else</span></span><br><span class="line">       disp(<span class="string">&#x27;请确保输入数据的是 1，2，3 中的其中一个&#x27;</span>);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛 DF 数据拟合算法（Data Fitting）</title>
      <link href="/2022/08/07/DF%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88/"/>
      <url>/2022/08/07/DF%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）GUIDANCE"><a href="#（一）GUIDANCE" class="headerlink" title="（一）GUIDANCE"></a>（一）GUIDANCE</h1><h2 id="什么是数据拟合"><a href="#什么是数据拟合" class="headerlink" title="什么是数据拟合"></a>什么是数据拟合</h2><p>已知一组（二维）数据，即平面上的 $n$ 个点 $(x_i,y_i),\quad \forall i = 1,2,\cdots,n $， $x_i$ 互不相同，寻求一个函数（曲线） $f(x)$ ，使得 $f(x)$ 在某种意义（准则）下与所有的数据点最为接近，这个过程就是<strong>数据拟合</strong></p><h2 id="曲线拟合的线性最小二乘法"><a href="#曲线拟合的线性最小二乘法" class="headerlink" title="曲线拟合的线性最小二乘法"></a>曲线拟合的线性最小二乘法</h2><p>一般情况下，我们指的“准则”就是线性最小二乘法，线性最小二乘法是解决曲线拟合最常用的方法</p><blockquote><p>本文的符号中，字母上加 ^ 符号表示拟合值</p></blockquote><p>我们假设通过拟合得到的线性函数是：$\widehat{y_i} = \widehat{k}x_i+\widehat{b}$</p><p>那么经过最小二乘法确定参数的方法就是：$\widehat{k},\widehat{b}=arg_{k,b}min(\sum_{i=1}^n|y_i-\widehat{y_i}|)$</p><p>经过数学推导，可以得到线性最小二乘法拟合的参数求解公式：</p><p><img src="https://s1.ax1x.com/2022/08/08/vMvYf1.png" alt="Image"></p><p><img src="https://s1.ax1x.com/2022/08/08/vMvUl6.png" alt="Image"></p><blockquote><p>事实上，拟合的方法远不止线性拟合，这里先以线性拟合作为引子</p></blockquote><h2 id="数据拟合和数据插值的区别"><a href="#数据拟合和数据插值的区别" class="headerlink" title="数据拟合和数据插值的区别"></a>数据拟合和数据插值的区别</h2><blockquote><p>这里直接粘贴写在另一篇笔记中的内容：</p></blockquote><ul><li><p>插值：求已知有限个数据点的近似函数。数模比赛中，常常需要根据已知的样本点进行数据的处理和分析，对于数据量少到不足以去分析问题，而必须生成一些合理的数据，这时我们就会考虑采用插值算法</p></li><li><p>拟合：已知有限个数据点，求近似函数，在样本点较少的情况下，用拟合算法拟合出来的曲线并没有插值算法得到的准确。如果样本点太多，那么插值算法得到的多项式次数过高，会造成“龙格现象”，尽管插值可以通过分段进行解决，但有时我们更希望得到一个精确的函数，因此我们倾向于使用拟合算法进行替代</p></li></ul><blockquote><p>拟合不要求过已知的数据点（插值则要求），而是按某种意义下（一般是最小二乘意义下）得到和所有点的分布最“接近”的函数</p><p>插值和拟合在使用时需要进行区分，根据不同的使用情景来确定不同的方法</p></blockquote><h1 id="（二）拟合效果评价"><a href="#（二）拟合效果评价" class="headerlink" title="（二）拟合效果评价"></a>（二）拟合效果评价</h1><p>我们一般依据下面三个指标来确定拟合的好坏：</p><h2 id="误差平方和"><a href="#误差平方和" class="headerlink" title="误差平方和"></a>误差平方和</h2><p>误差平方和：$SSE = \sum_{i=1}^n(y_i-\widehat{y_i})^2$</p><p>根据误差平方和还能给出均方差的计算公式</p><script type="math/tex; mode=display">MSE = \frac{SSE}{n} = \frac{1}{n}\sum_{i=1}^n(y_i-\widehat{y_i})^2</script><h2 id="回归平方和"><a href="#回归平方和" class="headerlink" title="回归平方和"></a>回归平方和</h2><p>回归平方和：$SSR = \sum_{i=1}^n(\widehat{y_i}-\overline{y})^2$</p><h2 id="拟合优度"><a href="#拟合优度" class="headerlink" title="拟合优度"></a>拟合优度</h2><p>总体平方和：$SST = \sum_{i=1}^n(y_i-\overline{y})^2$</p><p>不难看出会有：$SST=SSE+SSR$</p><p>我们可以用可以用拟合优度（可决系数）作为拟合好坏的评价指标：</p><script type="math/tex; mode=display">    0 \leq R^2 = \frac{SSR}{SST} = \frac{SST-SSE}{SST} \leq 1</script><p>那么， $\frac{SSR}{SST}$ 越大，即 $R^2$ 越接近 $1$ ，就有误差越小，拟合效果越好 </p><blockquote><p>ATTENTION：使用这种评价标准要求参数是一次的，在设计拟合函数时应该注意</p></blockquote><h1 id="（三）多项式拟合函数-polyfit"><a href="#（三）多项式拟合函数-polyfit" class="headerlink" title="（三）多项式拟合函数 polyfit"></a>（三）多项式拟合函数 <code>polyfit</code></h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><ul><li><p>多项式拟合函数 <code>coeff = polyfit(x_sample, y_sample, degree)</code> </p><ul><li><p>第一个参数传入样本点的横坐标数组</p></li><li><p>第二个参数传入样本点的纵坐标数组</p></li><li><p>第三个参数传入我们需要构造的多项式的次数</p></li><li><p>返回值 <code>coeff</code> 是多项式的系数数组</p></li></ul></li><li><p>多项式值计算函数 <code>y_output = polyval(ceoff, x_input)</code></p><ul><li><p>第一个参数传入多项式的系数数组</p></li><li><p>第二个参数传入多项式的自变量值数组</p></li><li><p>返回值 <code>y_output</code> 是多项式的因变量值数组</p></li></ul></li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下代码保存在 <code>polyfit_test.m</code> 中，可前往 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm">GitHub 仓库下载</a></p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x_sample <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">y_sample <span class="built_in">=</span> [<span class="number">9</span> <span class="number">7</span> <span class="number">6</span> <span class="number">3</span> -<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">7</span> <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">plot(x_sample, y_sample, <span class="string">&#x27;bo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hold on;</span><br><span class="line"></span><br><span class="line">coeff <span class="built_in">=</span> polyfit(x_sample, y_sample, <span class="number">3</span>);   <span class="comment">%三阶多项式拟合</span></span><br><span class="line"></span><br><span class="line">x_input <span class="built_in">=</span> <span class="number">0</span>:.<span class="number">2</span>:<span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line">y_output <span class="built_in">=</span> polyval(coeff, x_input);  <span class="comment">%求对应y值</span></span><br><span class="line"></span><br><span class="line">plot(x_input, y_output, <span class="string">&#x27;r-&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>输出结果如下，蓝色散点图表示输入样本点，红色实线表示拟合函数</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vMvNSx.png width = 47%></center><h1 id="（四）万能模型拟合-fit"><a href="#（四）万能模型拟合-fit" class="headerlink" title="（四）万能模型拟合 fit"></a>（四）万能模型拟合 <code>fit</code></h1><blockquote><p>注意：在 <code>MATLAB</code> 中还有一个叫做 <code>ninfit</code> 的函数，两个函数有一定的区别，这里只介绍 <code>fit</code></p><p><code>fit</code> 函数也是在曲线拟合工具箱 <code>Curve Fitting Toolbox</code> 中采用的函数</p></blockquote><h2 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h2><p><code>[fitresult, gof] = fit( xData, yData, fit_type, options );</code></p><ul><li><p>第一个参数传入样本点的自变量坐标数组</p><blockquote><p>不一定是 $x$ 轴坐标，也可以是 $x,y$ 两轴坐标合并为一个数组作为自变量，如下</p><p><code>[fitresult, gof] = fit( [xData, yData], zData, ft, &#39;Normalize&#39;, &#39;on&#39; );</code></p></blockquote></li><li><p>第二个参数传入样本点的因变量坐标数组</p></li><li><p>第三个参数传入拟合函数的拟合类型，需要先用 <code>fittype</code> 函数处理，如下</p><ul><li>如果拟合类型是 <code>fit</code> 函数已经内置的类型，直接使用 <code>ft = fittype( &#39;gaussl&#39; );    % 高斯拟合</code></li><li><p>如果拟合类型不是 <code>fit</code> 函数已经内置的类型，而是我们自己新定义的类型，那么可以如下操作</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 下面采用匿名函数的方法进行定义，但你并不需要精通掌握匿名函数的规则，只需要知道下面的格式和规则</span></span><br><span class="line"><span class="comment">% 命名格式是：fittype(@(参数列表) 拟合函数形式)</span></span><br><span class="line"><span class="comment">% 注意自变量必须是 x</span></span><br><span class="line"><span class="comment">% 注意参数要放在自变量前面，在下面的代码中，匿名函数参数的形式为(a, b, c, x)，便遵循了这一规则</span></span><br><span class="line">ft <span class="built_in">=</span> fittype(@(a, b, c, x) a*x^<span class="number">3</span> + b* x^<span class="number">2</span> + c*x );</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第一个返回值是拟合得到的函数模型结果</p></li><li><p>第二个返回值是包含拟合优度信息的结构体</p></li></ul><blockquote><p>如何使用这两个返回值会在（五）中介绍，它们等价于（五）中的 <code>fittedmodel</code> 和 <code>goodness</code></p></blockquote><h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下代码保存在 <code>fit_test1.m</code> 中，可前往 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm">GitHub 仓库下载</a></p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function [fitresult, gof] <span class="built_in">=</span> fit_test2(x_sample, y_sample, z_sample)</span><br><span class="line"><span class="comment">%CREATEFIT(X_SAMPLE,Y_SAMPLE,Z_SAMPLE)</span></span><br><span class="line"><span class="comment">%  创建一个拟合。</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%  要进行 &#x27;傅里叶拟合2&#x27; 拟合的数据:</span></span><br><span class="line"><span class="comment">%      X 输入: x_sample</span></span><br><span class="line"><span class="comment">%      Y 输入: y_sample</span></span><br><span class="line"><span class="comment">%      Z 输出: z_sample</span></span><br><span class="line"><span class="comment">%  输出:</span></span><br><span class="line"><span class="comment">%      fitresult: 表示拟合的拟合对象</span></span><br><span class="line"><span class="comment">%      gof: 带有拟合优度信息的结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 拟合: &#x27;傅里叶拟合2&#x27;。</span></span><br><span class="line">[xData, yData, zData] <span class="built_in">=</span> prepareSurfaceData( x_sample, y_sample, z_sample );</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置 fittype 和选项。</span></span><br><span class="line">ft <span class="built_in">=</span> <span class="string">&#x27;linearinterp&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对数据进行模型拟合。</span></span><br><span class="line">[fitresult, gof] <span class="built_in">=</span> fit( [xData, yData], zData, ft, <span class="string">&#x27;Normalize&#x27;</span>, <span class="string">&#x27;on&#x27;</span> );</span><br></pre></td></tr></table></figure><blockquote><p>用图窗显示结果如下</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vMv0mD.png width = 45%></center><h1 id="（五）利用-Curve-Fitting-Toolbox-进行拟合"><a href="#（五）利用-Curve-Fitting-Toolbox-进行拟合" class="headerlink" title="（五）利用 Curve Fitting Toolbox 进行拟合"></a>（五）利用 Curve Fitting Toolbox 进行拟合</h1><blockquote><p>没有安装该应用需要提前安装：<code>Curve Fitting Toolbox</code></p><p>这个工具箱事实上是调用了 <code>MATLAB</code> 的内置函数，并且提供了方便可视化界面和绘图操作</p></blockquote><p>利用工具箱进行函数的操作非常容易，简要步骤如下：</p><ol><li>在当前工作区创建数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; x_sample = [1 2 3 4 5 6 7 8 9];</span><br><span class="line">&gt;&gt; y_sample = [9 7 6 3 -1 2 5 7 20];</span><br><span class="line">&gt;&gt; x_input = 0:.2:10;</span><br></pre></td></tr></table></figure><ol><li>打开曲线拟合器，在曲线拟合器中选择数据（会自动在列表中呈现工作区数据以供选择）</li></ol><center><img src = https://s1.ax1x.com/2022/08/08/vMva6K.png width = 32%></center><ol><li>选择不同模型，优化拟合结果</li></ol><blockquote><p>该工具箱能够自动导出拟合优度，如下：</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vMvJYR.png width = 22%></center><ol><li>导出拟合模型、图窗，如下：</li></ol><blockquote><p>下图为拟合图窗</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vMvdOO.png width = 45%></center><blockquote><p>拟合模型可以导出到工作区，然后直接作为函数调用</p></blockquote><ul><li><p>我们将模型导为 <code>fittedmodel</code> ，就能够直接在命令行中输入 <code>&gt;&gt; fittedmodel(x_input)</code> 进行预测，其中 <code>x_input</code> 指的是待预测数组，这个函数将输出预测得到的值 <code>y_output</code>，直接在命令行中输入 <code>&gt;&gt; fittedmodel</code> 也可以直接查看拟合的函数模型</p></li><li><p>我们将合优度导为 <code>goodness</code> ，可以直接在命令行中输入 <code>&gt;&gt; goodness</code> 查看拟合优度结构体字段</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛 DI 数据插值算法（Data Interpolation）</title>
      <link href="/2022/08/07/DI%E6%95%B0%E6%8D%AE%E6%8F%92%E5%80%BC/"/>
      <url>/2022/08/07/DI%E6%95%B0%E6%8D%AE%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）GUIDANCE"><a href="#（一）GUIDANCE" class="headerlink" title="（一）GUIDANCE"></a>（一）GUIDANCE</h1><h2 id="插值和拟合的概念"><a href="#插值和拟合的概念" class="headerlink" title="插值和拟合的概念"></a>插值和拟合的概念</h2><ul><li><p>插值：求已知有限个数据点的近似函数。数模比赛中，常常需要根据已知的样本点进行数据的处理和分析，对于数据量少到不足以去分析问题，而必须生成一些合理的数据，这时我们就会考虑采用插值算法</p></li><li><p>拟合：已知有限个数据点，求近似函数，在样本点较少的情况下，用拟合算法拟合出来的曲线并没有插值算法得到的准确。如果样本点太多，那么插值算法得到的多项式次数过高，会造成“龙格现象”，尽管插值可以通过分段进行解决，但有时我们更希望得到一个精确的函数，因此我们倾向于使用拟合算法进行替代</p></li></ul><blockquote><p>拟合不要求过已知的数据点（插值则要求），而是按某种意义下（一般是最小二乘意义下）得到和所有点的分布最“接近”的函数</p><p>插值和拟合在使用时需要进行区分，根据不同的使用情景来确定不同的方法</p></blockquote><h2 id="概念提示"><a href="#概念提示" class="headerlink" title="概念提示"></a>概念提示</h2><ul><li><p>被插值函数：原始函数，一系列点遵循这个原始函数来分布，被插值函数可能是不存在的，但是我们每次插值前假定所有样本点遵照这个被插值函数进行分布</p></li><li><p>插值函数：由我们根据样本点构造出来的函数，其宗旨是尽量符合被插值函数，即同时满足：完全符合已知样点分布的情况，尽量接近被插值函数中未知点的分布情况</p></li></ul><h2 id="插值算法的应用方法"><a href="#插值算法的应用方法" class="headerlink" title="插值算法的应用方法"></a>插值算法的应用方法</h2><ol><li><p>得到所有已知的样本点</p></li><li><p>选择合适合理的插值算法</p></li><li><p>根据这种插值算法和已知的样本点确认插值函数</p><blockquote><p>该笔记中使用的 <code>MATLAB</code> 函数都有统一的输入形式：第一个参数是样本点数组的 $x$ 值（数组），第二个参数是样本点数组的 $x$ 值（数组），第三个参数是插值点数组的横坐标 $x_input$（数组）</p></blockquote></li><li>根据插值函数就能够得到样本点以外的其它（我们自行构造的）数据</li></ol><h1 id="（二）插值算法原理"><a href="#（二）插值算法原理" class="headerlink" title="（二）插值算法原理"></a>（二）插值算法原理</h1><p>假设有 $n+1$ 个互不相同的节点 $(x_i,y_i),\quad \forall i = 0,1,2,\cdots,n$，其中若$i\ne j$ 则 $x_i \ne x_j$</p><p>则存在唯一的多项式：$I_n(x) = a_0 + a_1x + a_2x^2+\cdots+a_nx^n$</p><p>使得$I_n(x_j) = y_j,\quad \forall j = 0,1,2,\cdots,n$</p><blockquote><p>根据线性代数的基本知识，我们知道过 $n+1$ 个横坐标互不相同的点能且只能确定唯一一个 $n$ 次方程</p><p>利用代数学的知识解释就是：</p><p>如果设待插值函数的 $n+1$ 个已知点为 $(x_i,y_i),\quad \forall i = 0,1,2,\cdots,n$，而插值函数 $I_n(x)$ 的所有系数看作一组代求的未知量 $(a_0,a_1,\cdots,a_n)$，那么这组未知量就是下面方程的解</p><script type="math/tex; mode=display">A = \begin{pmatrix} 1&x_0&\cdots&x_0^n\\ 1&x_1&\cdots&x_1^n\\ \vdots&\vdots&\ddots&\vdots\\ 1&x_n&\cdots&x_n^n \end{pmatrix} ,\quad X = (a_0,a_1,\cdots,a_n)^T,\quad Y = (y_0,y_1,\cdots,y_n)^T,\quad AX = Y</script><p>其中不难发现 $A$ 为范特蒙德行列式， $|A| = \prod_{i=1}^n\prod_{j=0}^{i-1}(x_i-x_j) \ne 0$ ，故根据克莱姆法则，方程有唯一解，即<strong>在确定次数德情况下</strong>，符合条件的方程有且只有一个</p></blockquote><h1 id="（三）-插值算法1：分段线性插值算法"><a href="#（三）-插值算法1：分段线性插值算法" class="headerlink" title="（三） 插值算法1：分段线性插值算法"></a>（三） 插值算法1：分段线性插值算法</h1><h2 id="分段插值介绍"><a href="#分段插值介绍" class="headerlink" title="分段插值介绍"></a>分段插值介绍</h2><p>分段线性插值算法非常简单，就是在获得的任意两个样本点之间计算一次函数，这样就能通过 $n$ 个样本点得到 $n-1$ 段的分段一次函数，其优点就是简单明晰，运算量小，缺点是在节点不够多时可能不够精确，得到的结果也不够光滑（存在角点），即分段函数的交接处可能不具有导数</p><h2 id="分段插值原理"><a href="#分段插值原理" class="headerlink" title="分段插值原理"></a>分段插值原理</h2><p>假设有两个相邻节点 $(x_1,y_1),(x_2,y_2)$，那么在这两个相邻节点之间的一次线性方程为</p><script type="math/tex; mode=display">y = \frac{x-x_2}{x_1-x_2}y_1+\frac{x-x_1}{x_2-x_1}y_2</script><p>证明过程涉及初中数学，不过多解释</p><h2 id="分段插值法代码"><a href="#分段插值法代码" class="headerlink" title="分段插值法代码"></a>分段插值法代码</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function y_output <span class="built_in">=</span> PLI(x, y, x_input) </span><br><span class="line"><span class="comment">% Piecewise_Linear_Interpolate</span></span><br><span class="line"><span class="comment">% 该函数实现分段线性插值</span></span><br><span class="line"><span class="comment">% (x,y)为已知的数据点，这两个参数应该是长度一致的数组</span></span><br><span class="line"><span class="comment">% x_input为待插值的横坐标</span></span><br><span class="line"><span class="comment">% y_output为插值后的到的结果</span></span><br><span class="line"> </span><br><span class="line">sizex <span class="built_in">=</span> length(x);</span><br><span class="line">size_x_input <span class="built_in">=</span> length(x_input);</span><br><span class="line">y_output <span class="built_in">=</span> zeros(size_x_input);</span><br><span class="line"></span><br><span class="line">for j <span class="built_in">=</span> <span class="number">1</span> : size_x_input</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : sizex - <span class="number">1</span></span><br><span class="line">        <span class="built_in">if</span> (x_input(j) &gt; x(i) &amp;&amp; x_input(j) <span class="built_in">&lt;=</span> x(i+<span class="number">1</span>)) <span class="comment">% 判断 x_input 在那个区间内</span></span><br><span class="line">            <span class="comment">% 在相应的区间中套用公式求出 y_output</span></span><br><span class="line">            y_output(j) <span class="built_in">=</span> ((x_input(j) - x(i + <span class="number">1</span>)) / (x(i) - x(i+<span class="number">1</span>))) * y(i) + (((x_input(j) - x(i))/(x(i + <span class="number">1</span>) - x(i))) * y(i + <span class="number">1</span>));  </span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>分段插值测试代码</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%分段线性插值测试</span></span><br><span class="line">x <span class="built_in">=</span> <span class="number">0</span> : <span class="number">2</span>*pi;</span><br><span class="line">y <span class="built_in">=</span> exp(x);   <span class="comment">% 构造一个指数模型作为被插值函数</span></span><br><span class="line">x_input <span class="built_in">=</span> <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">6</span>;</span><br><span class="line">y_output <span class="built_in">=</span> PLI(x,y,x_input);</span><br><span class="line">plot(x, y, <span class="string">&#x27;b+&#x27;</span>, x_input, y_output, <span class="string">&#x27;r:&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>测试代码在 <code>MATLAB</code> 上的输出结果如下（蓝色加号是样本点，红色点线是插值点的连线）</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQpQ3R.png width = 42%></center><h1 id="（四）插值算法2：拉格朗日多项式插值法"><a href="#（四）插值算法2：拉格朗日多项式插值法" class="headerlink" title="（四）插值算法2：拉格朗日多项式插值法"></a>（四）插值算法2：拉格朗日多项式插值法</h1><h2 id="拉格朗日多项式插值法原理"><a href="#拉格朗日多项式插值法原理" class="headerlink" title="拉格朗日多项式插值法原理"></a>拉格朗日多项式插值法原理</h2><p>如上我们已经验证如下 $n+1$ 次方程一定会有 $n+1$ 个根，分别是多项式 $I_n(x) = a_0 + a_1x + a_2x^2+\cdots+a_nx^n$ 的所有系数</p><script type="math/tex; mode=display">A = \begin{pmatrix} 1&x_0&\cdots&x_0^n\\ 1&x_1&\cdots&x_1^n\\ \vdots&\vdots&\ddots&\vdots\\ 1&x_n&\cdots&x_n^n \end{pmatrix} ,\quad X = (a_0,a_1,\cdots,a_n)^T,\quad Y = (y_0,y_1,\cdots,y_n)^T,\quad AX = Y</script><p>根据这些信息，我们可以直接给出 $n+1$ 次方程的形式，即：</p><script type="math/tex; mode=display">    I(x) = y_1\frac{(x-x_2)(x-x_3)\cdots(x-x_n)}{(x_1-x_2)(x_1-x_3)\cdots(x_1-x_n)}+y_2\frac{(x-x_1)(x-x_3)\cdots(x-x_n)}{(x_2-x_1)(x_2-x_3)\cdots(x_2-x_n)}+\cdots+y_n\frac{(x-x_1)(x-x_2)\cdots(x-x_{n-1})}{(x_n-x_1)(x_n-x_2)\cdots(x_n-x_{n-1})}</script><p>简写为：</p><script type="math/tex; mode=display">    \sum_{i=1}^ny_i\prod_{j=1,j\ne i}^n\frac{x-x_j}{x_i-x_j}</script><blockquote><p>上面这个式子就是插值多项式，这个结论只需要将所有点 $(x_i,y_i),\quad \forall i = 0,1,2,\cdots,n$ 代入验证即可，至于如何构造出的这个巧妙的式子，我们并不需要深入了解</p></blockquote><h2 id="拉格朗日多项式插值法代码"><a href="#拉格朗日多项式插值法代码" class="headerlink" title="拉格朗日多项式插值法代码"></a>拉格朗日多项式插值法代码</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function y_output <span class="built_in">=</span> LI(x, y, x_input)</span><br><span class="line"><span class="comment">% 样本点数据以数组 x , y 输入，插值点以数组 input_x 输入，输出数组output_y为插值。</span></span><br><span class="line">size_x <span class="built_in">=</span> length(x);</span><br><span class="line">size_x_input <span class="built_in">=</span> length(x_input);</span><br><span class="line">y_output <span class="built_in">=</span> zeros(size_x_input);</span><br><span class="line"></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : size_x_input</span><br><span class="line">    z <span class="built_in">=</span> x_input(i);</span><br><span class="line">    s <span class="built_in">=</span> <span class="number">0.0</span>;</span><br><span class="line">    for k <span class="built_in">=</span> <span class="number">1</span> : size_x</span><br><span class="line">        p <span class="built_in">=</span> <span class="number">1.0</span>;</span><br><span class="line">        for j <span class="built_in">=</span> <span class="number">1</span> : size_x</span><br><span class="line">            <span class="built_in">if</span> j ~<span class="built_in">=</span> k</span><br><span class="line">            p <span class="built_in">=</span> p * (z - x(j))/(x(k) - x(j));</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        s <span class="built_in">=</span> p*y(k) + s;</span><br><span class="line">    end</span><br><span class="line">    y_output(i) <span class="built_in">=</span> s;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>直接使用分段插值的测试代码测试该函数，得到拟合的函数图像如下（蓝色加号是样本点，红色点线是插值点的连线）</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQpu4J.png width = 42%></center><h1 id="（五）插值算法3：牛顿插值法"><a href="#（五）插值算法3：牛顿插值法" class="headerlink" title="（五）插值算法3：牛顿插值法"></a>（五）插值算法3：牛顿插值法</h1><h2 id="牛顿插值法介绍"><a href="#牛顿插值法介绍" class="headerlink" title="牛顿插值法介绍"></a>牛顿插值法介绍</h2><p>拉格朗日插值公式在插值节点发生改变时，插值公式随之就要重新计算生成。事实上，牛顿插值法和拉格朗日插值法的结果相同，但是表示形式不同，由此形成的计算思路也不相同</p><h2 id="牛顿插值法原理"><a href="#牛顿插值法原理" class="headerlink" title="牛顿插值法原理"></a>牛顿插值法原理</h2><p>首先应该先定义<strong>差商</strong>的概念：</p><script type="math/tex; mode=display">一阶差商：f[x_i,x_j] = \frac{f(x_i)-f(x_j)}{x_i-x_j}</script><script type="math/tex; mode=display">二阶差商： f[x_i,x_j,x_k] = \frac{f[x_i,x_j]-f[x_j,x_k]}{x_i-x_k}</script><script type="math/tex; mode=display">k阶差商：f[x_0,x_1,\cdots,x_n] = \frac{f[x_0,x_1,\cdots,x_{n-1}]-f[x_1,x_2,\cdots,x_n]}{x_0-x_n}</script><p>在这样的定义下，可以得到插值的计算公式，假设有 $n+1$ 个样本点为 $(x_i,y_i),\quad \forall i = 0,1,2,\cdots,n$，那么有：</p><script type="math/tex; mode=display">f(x) = a_0+a_1(x-x_0)+\cdots+a_n(x-x_0)(x-x_1)\cdots(x-x_{n-1})</script><script type="math/tex; mode=display">其中\quad a_k = f[x_0,x_1,\cdots,x_k],\quad \forall k = 0,1,2,\cdots,n</script><h2 id="牛顿插值法的优越性"><a href="#牛顿插值法的优越性" class="headerlink" title="牛顿插值法的优越性"></a>牛顿插值法的优越性</h2><p><strong>可以通过继承已经计算得到的结果实现灵活而强大的可扩展性</strong></p><p>比如新添加一个样本节点 $(x_{n+1},y_{n+1})$ ，对于拉格朗日插值法而言，需要重构整个式子，再计算所有结果，这势必造成大量的计算冗余和浪费</p><p>而牛顿插值法的特殊形式在于 $k$ 阶差商和 $x_{k+1}$ 毫无关系，这意味着插值计算式 $f(x) = a_0+a_1(x-x_0)+\cdots+a_n(x-x_0)(x-x_1)\cdots(x-x_{n-1})$ 的前 $n$ 项都不必改动，只需要在最后进一步计算出 $a_n$ 然后在插值计算式末尾再添加一项即可，这个方法具有很强的计算优越性</p><h2 id="牛顿插值法代码"><a href="#牛顿插值法代码" class="headerlink" title="牛顿插值法代码"></a>牛顿插值法代码</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function y_output <span class="built_in">=</span> NI(x, y, x_input)</span><br><span class="line">x_size <span class="built_in">=</span> length(x);</span><br><span class="line">x_input_size <span class="built_in">=</span> length(x_input);</span><br><span class="line">dqTable <span class="built_in">=</span> zeros(x_size,x_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 对差商表第一列赋值</span></span><br><span class="line">for k <span class="built_in">=</span> <span class="number">1</span> : x_size      </span><br><span class="line">    dqTable(k) <span class="built_in">=</span> y(k);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 求差商表</span></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">2</span> : x_size       <span class="comment">% 差商表从0阶开始,矩阵从1维开始存储</span></span><br><span class="line">    for k <span class="built_in">=</span> i : x_size</span><br><span class="line">        dqTable(k, i) <span class="built_in">=</span> (dqTable(k, i-<span class="number">1</span>) - dqTable(k-<span class="number">1</span>, i-<span class="number">1</span>)) / (x(k) - x(k + <span class="number">1</span> - i));  </span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">disp(<span class="string">&#x27;差商表如下：&#x27;</span>);</span><br><span class="line">disp(dqTable);</span><br><span class="line"></span><br><span class="line">y_output <span class="built_in">=</span> zeros(x_input_size);  </span><br><span class="line"></span><br><span class="line"><span class="comment">%% 求插值多项式</span></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : x_input_size</span><br><span class="line">    for k <span class="built_in">=</span> <span class="number">2</span> : x_size</span><br><span class="line">        t <span class="built_in">=</span> <span class="number">1</span>;</span><br><span class="line">        for j <span class="built_in">=</span> <span class="number">1</span> : k-<span class="number">1</span></span><br><span class="line">            t <span class="built_in">=</span> t * (x_input(i) - x(j));</span><br><span class="line">            <span class="comment">% disp(t)</span></span><br><span class="line">        end</span><br><span class="line">        y_output(i) <span class="built_in">=</span> dqTable(k,k) * t + y_output(i);</span><br><span class="line">    end</span><br><span class="line">    y_output(i) <span class="built_in">=</span> dqTable(<span class="number">1</span>,<span class="number">1</span>) + y_output(i);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">% disp(y_output)</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>直接使用分段插值的测试代码测试该函数，得到拟合的函数图像如下（蓝色加号是样本点，红色点线是插值点的连线）</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQpMC9.png width = 42%></center><h2 id="补充：龙格现象"><a href="#补充：龙格现象" class="headerlink" title="补充：龙格现象"></a>补充：龙格现象</h2><p>在数值分析中，高次插值会产生龙格现象（Runge phenomenon）。即在两端处波动极大，产生明显的震荡。</p><p>也因此，我们在实践中一般<strong>不轻易使用高次插值</strong></p><blockquote><p>如下图，红色线条是原始标准函数，蓝色线条是我们根据不同的插值节点选取得到的拟合函数</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQp1jx.png width = 42%></center><h1 id="（六）插值算法4：埃尔米特插值法"><a href="#（六）插值算法4：埃尔米特插值法" class="headerlink" title="（六）插值算法4：埃尔米特插值法"></a>（六）插值算法4：埃尔米特插值法</h1><h2 id="埃尔米特插值法介绍"><a href="#埃尔米特插值法介绍" class="headerlink" title="埃尔米特插值法介绍"></a>埃尔米特插值法介绍</h2><p>埃尔米特（Hermite）分段插值方法，不仅能够满足在节点处与函数同值，而且能够实现函数有相同的一阶、二阶甚至更高阶的导数值</p><p>由于它优越的特性，Hermite 插值法是解决数学建模中预测类问题的最常用的方法</p><ul><li>埃尔米特插值方法的原理</li></ul><center><img src = https://s1.ax1x.com/2022/08/08/vQplg1.png width = 82%>[原理具体还可以参照这里（点击跳转）](https://blog.csdn.net/SanyHo/article/details/106849323)</center><h2 id="埃尔米特插值方法代码实现"><a href="#埃尔米特插值方法代码实现" class="headerlink" title="埃尔米特插值方法代码实现"></a>埃尔米特插值方法代码实现</h2><p>Hermite 插值有现成可用的 markdown 函数，如下：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x <span class="built_in">=</span> -<span class="number">3</span>:<span class="number">3</span>; </span><br><span class="line">y <span class="built_in">=</span> [-<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]; </span><br><span class="line">xq1 <span class="built_in">=</span> -<span class="number">3</span>:.<span class="number">01</span>:<span class="number">3</span>;</span><br><span class="line">p <span class="built_in">=</span> pchip(x,y,xq1);</span><br><span class="line">s <span class="built_in">=</span> spline(x,y,xq1);</span><br><span class="line">m <span class="built_in">=</span> makima(x,y,xq1);</span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xq1,p,<span class="string">&#x27;-&#x27;</span>,xq1,s,<span class="string">&#x27;-.&#x27;</span>,xq1,m,<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">legend(<span class="string">&#x27;Sample Points&#x27;</span>,<span class="string">&#x27;pchip&#x27;</span>,<span class="string">&#x27;spline&#x27;</span>,<span class="string">&#x27;makima&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>)</span><br></pre></td></tr></table></figure><center><img src = https://s1.ax1x.com/2022/08/08/vQp8u6.png width = 42%></center><p>其中 <code>spline</code> 表示三次样条插值，而 <code>pchip</code> 表示三次分段埃尔米特插值</p><blockquote><p>这里顺带一提，上述线性插值法事实上也有 <code>MATLAB</code> 函数 <code>interp1</code>可以调用，如下</p></blockquote><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">x <span class="built_in">=</span> <span class="number">0</span>:<span class="number">2</span>*pi;    </span><br><span class="line">y <span class="built_in">=</span> sin(x);    </span><br><span class="line">xx <span class="built_in">=</span> <span class="number">0</span>:<span class="number">0.5</span>:<span class="number">2</span>*pi;    </span><br><span class="line">  </span><br><span class="line"><span class="comment">% interp1对sin函数进行分段线性插值，调用interp1的时候，默认的是分段线性插值    </span></span><br><span class="line">y1 <span class="built_in">=</span> interp1(x,y,xx,<span class="string">&#x27;linear&#x27;</span>);    </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);  </span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xx,y1,<span class="string">&#x27;r&#x27;</span>)    </span><br><span class="line">title(<span class="string">&#x27;分段线性插值&#x27;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="comment">% 临近插值    </span></span><br><span class="line">y2 <span class="built_in">=</span> interp1(x,y,xx,<span class="string">&#x27;nearest&#x27;</span>);    </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);  </span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xx,y2,<span class="string">&#x27;r&#x27;</span>);    </span><br><span class="line">title(<span class="string">&#x27;临近插值&#x27;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="comment">% 使用非结终止条件的样条插值    </span></span><br><span class="line">y3 <span class="built_in">=</span> interp1(x,y,xx,<span class="string">&#x27;spline&#x27;</span>);    </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);  </span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xx,y3,<span class="string">&#x27;r&#x27;</span>)    </span><br><span class="line">title(<span class="string">&#x27;使用非结终止条件的样条插值&#x27;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="comment">% 保形分段三次插值    </span></span><br><span class="line">y4 <span class="built_in">=</span> interp1(x,y,xx,<span class="string">&#x27;pchip&#x27;</span>);    </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);  </span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xx,y4,<span class="string">&#x27;r&#x27;</span>);    </span><br><span class="line">title(<span class="string">&#x27;保形分段三次插值&#x27;</span>)    </span><br></pre></td></tr></table></figure><blockquote><p>函数形式为 <code>y_output = interp1(x, y, x_input, &#39;method&#39;)</code> ， <code>method</code> 默认为 ‘linear’，有以下可选值</p></blockquote><p><img src="https://s1.ax1x.com/2022/08/08/vQpJHO.png" alt=""></p><p>上面列举的两个函数 <code>pchip</code> 和 <code>interp1</code> 都可以通过调用函数返回多项式结构体，具体可以参考 <a href="https://ww2.mathworks.cn/help//matlab/ref/pchip.html#bvjbxbd-2">官方文档 phip </a> 和 <a href="https://ww2.mathworks.cn/help/matlab/ref/interp1.html#btwp6lt-5">官方文档 interp1 </a></p><h1 id="（七）插值算法5：三次样条插值法"><a href="#（七）插值算法5：三次样条插值法" class="headerlink" title="（七）插值算法5：三次样条插值法"></a>（七）插值算法5：三次样条插值法</h1><h2 id="样条插值介绍"><a href="#样条插值介绍" class="headerlink" title="样条插值介绍"></a>样条插值介绍</h2><p>许多工程技术中提出的计算问题对插值函数的光滑性有较高要求，如飞机的机翼外形，内燃机的进、排气门的凸轮曲线，都要求曲线具有较高的光滑程度，不仅要连续，而且要有<strong>连续的曲率</strong>，这就导致了样条插值的产生。</p><p>样条（Spline）本来是工程设计中使用的一种绘图工具，它是富有弹性的细木条或细金属条。绘图员利用它把一些已知点连接成一条光滑曲线（称为样条曲线），并使连接点处有连续的曲率。</p><p>数学上将具有一定光滑性的分段多项式称为样条函数，即有：</p><p>对于给定区间 $[a,b]$ 中的 $a = x_0&lt;x_1&lt;\cdots&lt;x_{n-1}&lt;x_n=b$ ，如果函数 $f(x)$ 满足在每个小区间 $[x_{i-1},x_i]$ 上 $f(x)$ 是 $k$ 次多项式且具有 $k-1$ 阶连续导数，那么 $f(x)$ 就被称为样条函数</p><p>因此三次样条插值法中构造出的插值函数应该是具有 $2$ 阶连续导数的分段三次函数</p><h2 id="三次样条插值代码"><a href="#三次样条插值代码" class="headerlink" title="三次样条插值代码"></a>三次样条插值代码</h2><p>由于 <code>MATLAB</code> 上已经有已经编写封装的函数提供调用，因此我们这里就不再深入挖掘原理</p><p>三次样条插值的调用方法有两种：</p><p>一种是通过 <code>interp1</code> 函数并将 <code>method</code> 参数设置为 <code>spline</code></p><p>另一种是通过直接调用 <code>spline</code> 函数，它的参数输入和结果输出和 <code>pchip</code> 非常相似，这里不再重复论述，可以参考 <a href="https://ww2.mathworks.cn/help/matlab/ref/spline.html">官方文档 spline</a></p><h2 id="三次样条插值和三次埃尔米特分段插值的区别"><a href="#三次样条插值和三次埃尔米特分段插值的区别" class="headerlink" title="三次样条插值和三次埃尔米特分段插值的区别"></a>三次样条插值和三次埃尔米特分段插值的区别</h2><p>一方面，三次样条插值（<code>spline</code>）比三次埃尔米特分段插值（<code>pchip</code>）更加光滑，<code>spline</code>支持 $2$ 阶的导数连续，而 <code>pchip</code> 只能支持 $1$ 阶的导数连续</p><p>另一方面， <code>pchip</code>虽然牺牲了光滑性，但却是能够保形状的， <code>spline</code> 则不一定能够保形状</p><blockquote><p>可以用下面一张图展示它们的区别</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQp8u6.png width = 42%></center>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛 AHP 层次分析法</title>
      <link href="/2022/08/06/AHP%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2022/08/06/AHP%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）GUIDANCE"><a href="#（一）GUIDANCE" class="headerlink" title="（一）GUIDANCE"></a>（一）GUIDANCE</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>全称“层次权重决策分析方法”，一种解决多目标的复杂问题的定性与定量相结合的决策分析方法</p><p>在对复杂的决策问题的本质、影响因素及其内在关系等进行深入分析的基础上，利用较少的定量信息使决策的思维过程数学化，从而为多目标、多准则或无结构特性的复杂决策问题提供简便的决策方法</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>层次分析法根据问题的性质和要达到的总目标，将问题分解为不同的组成因素，并按照因素间的相互关联影响以及隶属关系将因素按不同层次聚集组合，形成一个多层次的分析结构模型，从而最终使问题归结为最低层（方案、措施层）相对于最高层（总目标层）的相对重要权值的确定或相对优劣次序的排定。</li><li>一致矩阵法的合理性：矩阵的一致程度越强，说明我们对不同因素的重要性做出的评估的“矛盾程度”越小，说明我们作出评估越准确</li></ol><hr><h1 id="（二）模型步骤"><a href="#（二）模型步骤" class="headerlink" title="（二）模型步骤"></a>（二）模型步骤</h1><h2 id="步骤一：建立层次结构模型"><a href="#步骤一：建立层次结构模型" class="headerlink" title="步骤一：建立层次结构模型"></a>步骤一：建立层次结构模型</h2><p>1） 确定最高层（总目标）、中间层（考虑的因素）、最低层（等待评估&amp;选择的方案），这三个层又被称为目标层、准则层和方案层</p><blockquote><p>事实上，准则层可以不只有一层，如果定的准则超过 9 个，一般我们选择进一步分出子准则层。</p></blockquote><p>2） 作图方法：<code>vscode</code> 插件 <code>Draw.io Integration</code>，如下：</p>   <center><img src = https://s1.ax1x.com/2022/08/06/vuos8H.png width = 55%></center><h2 id="步骤二：定性分析-amp-定性计算得到准则层判断矩阵"><a href="#步骤二：定性分析-amp-定性计算得到准则层判断矩阵" class="headerlink" title="步骤二：定性分析&amp;定性计算得到准则层判断矩阵"></a>步骤二：定性分析&amp;定性计算得到准则层判断矩阵</h2><p>1） 收集资料，对于准则层提出的各种准则的重要程度有一定的判断依据</p><p>2） 作出判断矩阵</p><div class="table-container"><table><thead><tr><th>因素/因素</th><th>价格</th><th>距离</th><th>口味</th><th>等待时间</th><th>餐厅装潢</th></tr></thead><tbody><tr><td>价格</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td><td>$a_{14}$</td><td>$a_{15}$</td></tr><tr><td>距离</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td><td>$a_{24}$</td><td>$a_{25}$</td></tr><tr><td>口味</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td><td>$a_{34}$</td><td>$a_{35}$</td></tr><tr><td>等待时间</td><td>$a_{41}$</td><td>$a_{42}$</td><td>$a_{43}$</td><td>$a_{44}$</td><td>$a_{45}$</td></tr><tr><td>餐厅装潢</td><td>$a_{51}$</td><td>$a_{52}$</td><td>$a_{53}$</td><td>$a_{54}$</td><td>$a_{55}$</td></tr></tbody></table></div><p>3） 两两进行互相比较分析（而不是把所有因素放在一起比较）</p><p>   一般而言，我们使用下面的标度方法：</p><div class="table-container"><table><thead><tr><th>$a_{ij}$ 值</th><th>含义</th></tr></thead><tbody><tr><td>$1$</td><td>因素 $i$ 和因素 $j$ 重要性相同</td></tr><tr><td>$3$</td><td>因素 $i$ 比因素 $j$ 稍微重要</td></tr><tr><td>$5$</td><td>因素 $i$ 比因素 $j$ 明显重要</td></tr><tr><td>$7$</td><td>因素 $i$ 比因素 $j$ 强烈重要</td></tr><tr><td>$9$</td><td>因素 $i$ 比因素 $j$ 极端重要</td></tr><tr><td>$2, 4, 6, 8$</td><td>中间值</td></tr><tr><td>上述值的倒数</td><td>$a_{ij} a_{ji} = 1$</td></tr></tbody></table></div><p>4） 比较过程中尽量考虑相对尺度，以提高准确度</p><ul><li>首先应该满足的是判断矩阵是一个正互矩阵：即满足 $a_{ij} {a_{ji}} = 1$</li><li>其次应该考虑作出的判断不应该明显有悖于已经作出的判断</li><li><p>判断矩阵的标度应该优先考虑题目中给出的信息和严谨的学术论文给出</p><p>严格遵循上面三个原则，我们给出判断矩阵各个方格中应该填的值</p><p>| 因素/因素 | 价格          | 距离          | 口味          | 等待时间 | 餐厅装潢 |<br>| ————- | ——————- | ——————- | ——————- | ———— | ———— |<br>| 价格      | $1$           | $1$           | $\frac{1}{3}$ | $2$      | $2$      |<br>| 距离      | $1$           | $1$           | $\frac{1}{3}$ | $2$      | $2$      |<br>| 口味      | $3$           | $3$           | $1$           | $6$      | $6$      |<br>| 等待时间  | $\frac{1}{2}$ | $\frac{1}{2}$ | $\frac{1}{6}$ | $1$      | $1$      |<br>| 餐厅装潢  | $\frac{1}{2}$ | $\frac{1}{2}$ | $\frac{1}{6}$ | $1$      | $1$      |</p><blockquote><p>由于我们遵循的判断标准非常严苛，我们发现上表有这样的特点：价格的标度是口味的标度 $\frac{1}{3}$ ，等待时间的标度是口味的 $\frac{1}{6}$ ，而价格的标度<strong>刚好</strong>是等待时间标度的 $2$ 倍，换句话说，即便在不同的因素之间，它们的重要程度也严格遵循相对尺度（$a_{ij}a_{jk} = a_{ik}$）</p><p>上面的说明也许使人困惑，但还可以这样理解：两两互相比较，这要求我们进行 $\frac{n(n-1)}{2}$ 次判断，但是由于严谨的标准，这 $\frac{n(n-1)}{2}$ 次判断的效果和只用同一个变量得到所有其它变量标度的效果一致</p><p>但是事实上我们给出的判断并不总是那么准确，有可能会出现变量不完全满足相对尺度的情形，这时我们需要通过对判断矩阵进行一致性检验来测算出现的误差是否在我们可以接受的范围内</p></blockquote></li></ul><h2 id="步骤三：对判断矩阵进行一致性检验"><a href="#步骤三：对判断矩阵进行一致性检验" class="headerlink" title="步骤三：对判断矩阵进行一致性检验"></a>步骤三：对判断矩阵进行一致性检验</h2><p>符号定义：</p><p>判断矩阵的最大特征根记为 $\lambda$ ，判断矩阵的规模（行数）记为 $n$ ，判断矩阵的一致性指标 $CI$ （衡量判断矩阵的一致性程度），随机一致性指标 $RI$ （一个通过查已知表得到的值），一致性比率 $CR$</p><p>1） 求出最大特征根 $\lambda$ </p><p>2） 求出矩阵的一致性指标 $CI$ </p><script type="math/tex; mode=display">CI = \frac{\lambda - n}{n-1}</script><p>3） 查表得到随机一致性指标 $RI$ </p><div class="table-container"><table><thead><tr><th>$n$</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>$RI$</td><td>0</td><td>0</td><td>0.58</td><td>0.90</td><td>1.12</td><td>1.24</td><td>1.32</td><td>1.41</td><td>1.45</td><td>1.49</td><td>1.51</td></tr></tbody></table></div><p>4） 求出一致性比率 $CR$ </p><script type="math/tex; mode=display">CR  = \frac{CI}{RI}</script><blockquote><p>一般情况下我们认为一致性比率 $CR &lt; 0.1$时，它的不一致程度在我们的允许范围内</p></blockquote><h2 id="步骤四：求解判断矩阵权重向量"><a href="#步骤四：求解判断矩阵权重向量" class="headerlink" title="步骤四：求解判断矩阵权重向量"></a>步骤四：求解判断矩阵权重向量</h2><p>求解权重向量一般有三种方法，可以全部使用，然后互相检验</p><p>前置知识：什么时向量归一化？</p><p>$(a_1,a_2,\dots,a_n)$ 归一化后为 $(\frac{a_1}{a_1+a_2+\dots+a_n},\frac{a_2}{a_1+a_2+\dots+a_n},\dots,\frac{a_1}{a_1+a_2+\dots+a_n})$</p><ul><li>算术平均法</li></ul><p>步骤：先将列向量全部归一化，再求解每一行的算术平均值，将这些算术平均值整合成一个列向量，再将这个列向量进行归一化，就能得到权重向量。</p><p>权重向量的第 $i$ 个分量为 $w_i$</p><script type="math/tex; mode=display">      w_i = \frac{1}{n}\sum_{j = 1}^{n}\frac{a_{ij}}{\sum_{k=1}^na_{kj}}</script><ul><li>几何平均法</li></ul><p>步骤：计算每一行的几何平均值（这个方法不需要先进行归一化），将这些几何平均值整合成一个列向量，再将这些向量进行归一化，就能得到权重向量。</p><p>权重向量的第 $i$ 个分量为 $w_i$</p><script type="math/tex; mode=display">      w_i = \frac{(\prod_{j=1}^na_{ij})^\frac{1}{n}}{\sum_{k=1}^{n}(\prod_{j=1}^na_{kj})^\frac{1}{n}}</script><ul><li>特征根法</li></ul><p>可以根据 2.5 的内容（一致矩阵的性质 3 ）得知：事实上一致的判断矩阵的最大特征值对应的特征向量可以直接视为第一列向量各分量的 k 倍（ k 是一个常数），将它归一化以后就是权重向量</p><p>这样，在一致性可以接受的情况下，我们只要求出最大特征值对应的特征向量，也能用来表示权重向量</p><p>步骤：求出判断矩阵的最大特征值对应的特征向量，将这个特征向量直接进行归一化得到权重向量</p><h2 id="求解各个方案在不同因素下的权重向量"><a href="#求解各个方案在不同因素下的权重向量" class="headerlink" title="求解各个方案在不同因素下的权重向量"></a>求解各个方案在不同因素下的权重向量</h2><p>使用如上描述的三种方法，同样可以列出各个方案在不同因素下的权重向量，如下我们依旧先给出方案层的判断矩阵</p><div class="table-container"><table><thead><tr><th>价格</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>距离</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>口味</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>等待时间</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>食堂装潢</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><p>根据这五个表格，可以经过 2.4 列举的三种方法求解出五个一维权重向量，它们分别代表东区二楼、西区一楼和中区二楼在五个不同因素下的评分。</p><h2 id="将准则层和方案层的权重向量整合到一个表格中，进行最终评估"><a href="#将准则层和方案层的权重向量整合到一个表格中，进行最终评估" class="headerlink" title="将准则层和方案层的权重向量整合到一个表格中，进行最终评估"></a>将准则层和方案层的权重向量整合到一个表格中，进行最终评估</h2><p>现在，我们可以根据已经求得的所有数据列出下面的表格</p><div class="table-container"><table><thead><tr><th></th><th>因素权重</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>价格</td><td>$w_1$</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>距离</td><td>$w_2$</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>口味</td><td>$w_3$</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr><tr><td>等待时间</td><td>$w_4$</td><td>$a_{41}$</td><td>$a_{42}$</td><td>$a_{43}$</td></tr><tr><td>食堂装潢</td><td>$w_5$</td><td>$a_{51}$</td><td>$a_{52}$</td><td>$a_{53}$</td></tr><tr><td>最终得分</td><td></td><td>$\sum_{i=1}^5 a_{i1}w_i$</td><td>$\sum_{i=1}^5 a_{i2}w_i$</td><td>$\sum_{i=1}^5 a_{i3}w_i$</td></tr></tbody></table></div><p>只需要比较 $\sum_{i=1}^5 a_{i1}w_i$ 、$\sum_{i=1}^5 a_{i2}w_i$ 和 $\sum_{i=1}^5 a_{i3}w_i$ 的大小就能作出评估</p><h2 id="一点补充（可以不看）：为什么我们这么在意最大特征值"><a href="#一点补充（可以不看）：为什么我们这么在意最大特征值" class="headerlink" title="一点补充（可以不看）：为什么我们这么在意最大特征值"></a>一点补充（可以不看）：为什么我们这么在意最大特征值</h2><p>我们对一致矩阵作出如下的定义：满足 $a_{ij}a_{jk} = a_{ik},1 \le i,j,k \le n$ 的矩阵被我们称为一致矩阵</p><blockquote><p>从这个定义中我们可以知道“一致”意味着什么：我们在作出两两比较判断的全过程严格遵照尺度（可以认为有一个严格遵循的标准）</p></blockquote><p> 一致矩阵的性质</p><p>  1）  一致矩阵的秩为 $1$ ，且一致矩阵任意两行之间成比例</p><p>  2）  一致矩阵的最大特征根为 $tr(判断矩阵) = n$ ，即判断矩阵的迹，其它特征根均为 0 </p><p>  3）  判断矩阵的最大特征值对应的特征向量为 $X = (\frac{k}{a_{11}},\frac{k}{a_{12}},\dots,\frac{k}{a_{1n}})^T$，其中 $k$ 为常数</p><p>我们来不严格地理解一下这些性质</p><ul><li>对于性质 1 </li></ul><p>由于一致矩阵有严格遵循的标准，换言之，我们知道 A 和 B 、C 、D之间的关系，自然也能够得到 B 和 C，B 和 D，C 和 D之间的关系，只需要第一行的信息就能够补充完整整个判断矩阵的内容。</p><p>整个判断矩阵中的有效信息只有第一行的信息，第一行以外的其它行的信息都能够被第一行的信息表示，因此一致矩阵的秩为 1</p><ul><li>对于性质 2 </li></ul><p>显然由于判断矩阵的对角线元素均为 $1$ ，故 $tr(判断矩阵) = n$</p><p>设判断矩阵为 $P$ ，满足 $PX = kX$，即 $(P-kI)X=O$</p><p>取 $k = 0$ 时，得到 $PX = O$，我们知道 $r(P) = 1$，那么显然 X 的基础解系的秩为 $n - 1$（自由未知量的个数） </p><p>那么 $k = 0$ 这一特征根的几何重数为 $n-1$，显然其代数重数大于等于 $n-1$ 且小于 $n$</p><blockquote><p>几何重数永远小于等于代数重数</p></blockquote><p>如果 $k = 0$ 这一特征根代数重数为 $n$ ，显然不能满足特征值的和为 $tr(P) = n$ ，因此它的代数重数为 $n-1$</p><p>剩下的一个特征根必然为 $tr(P) - 0 - 0 - \dots - 0 = tr(P) = n$</p><ul><li>对于性质 3</li></ul><p>$\dots$ $\dots$ 开摆</p><blockquote><p>综上，我们已经得到一个一致矩阵的最大特征值为 $n$ ，事实上，如果一个判断矩阵的最大特征值越接近 $n$ ，我们会认为它越接近一致的状态</p></blockquote><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul><li>考虑的因素和对象不能过多：平均随机一致性指标 $RI$ 的 $n$ 最大是 15 ，并且 n 太大容易产生误差</li><li>已经有充分已知数据的情形下不适合再使用层次分析法，因为层次分析法的一个重要的过程是我们根据事实和资料来确定标度，在已有数据均已确定的情形下显然不再适合自行确定标度</li></ul><h2 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h2><ol><li><p>列出总目标层、准则层、方案层</p></li><li><p>查找资料，填充准则层的判断矩阵</p><ul><li>对准则层的判断矩阵进行一致性检验，如不能通过应该调整矩阵的值直至通过</li><li>利用三种方法求出准则层的权重向量 W</li></ul></li><li><p>查找资料，分别就各个准则层因素来填充方案层的判断矩阵</p><ul><li>对每个方案层的判断矩阵进行一致性检验，如不能通过应该调整矩阵的值直至通过</li><li>利用三种方法求出每个方案层的权重向量 V</li></ul></li><li><p>将准则层的权重向量 W 和每个方案层的权重向量 V 列在一张表格中，进行最终分数评估</p></li></ol><hr><h1 id="（三）代码构建思路"><a href="#（三）代码构建思路" class="headerlink" title="（三）代码构建思路"></a>（三）代码构建思路</h1><h2 id="文本文件格式设置如下："><a href="#文本文件格式设置如下：" class="headerlink" title="文本文件格式设置如下："></a>文本文件格式设置如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请在下一行的开头分别输入准则层（先）和方案层（后）的规模（使用空格隔开）：</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">请在下面输入准则层矩阵</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">请在下面输入各个方案层的矩阵（注意顺序）</span><br><span class="line">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>只需要按照格式输入即可，比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">请在下一行的开头分别输入准则层（先）和方案层（后）的规模（使用空格隔开）：</span><br><span class="line">5 3</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">请在下面输入准则层矩阵</span><br><span class="line">1 0.5 4 3 3</span><br><span class="line">2 1 8 6 6</span><br><span class="line">0.25 0.125 1 0.875 0.875</span><br><span class="line">0.333 0.167 1.333 1 1</span><br><span class="line">0.333 0.167 1.333 1 1</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">请在下面输入各个方案层的矩阵（注意顺序）</span><br><span class="line">1 2 4</span><br><span class="line">0.5 1 2</span><br><span class="line">0.25 0.5 1</span><br><span class="line">1 0.333 0.125</span><br><span class="line">3 1 0.333</span><br><span class="line">8 3 1</span><br><span class="line">1 1 3</span><br><span class="line">1 1 3</span><br><span class="line">0.333 0.333 1</span><br><span class="line">1 3 4</span><br><span class="line">0.333 1 1</span><br><span class="line">0.25 1 1</span><br><span class="line">1 1 0.25</span><br><span class="line">1 1 0.25</span><br><span class="line">4 4 1</span><br><span class="line">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p><h2 id="代码文件已经附上详细注释"><a href="#代码文件已经附上详细注释" class="headerlink" title="代码文件已经附上详细注释"></a>代码文件已经附上详细注释</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">clc, clear  <span class="comment">% 清空当前的命令行窗口</span></span><br><span class="line">inFile <span class="built_in">=</span> fopen(<span class="string">&#x27;ahpInput.txt&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>); <span class="comment">% 以只读方式打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">if</span> (inFile <span class="built_in">=</span><span class="built_in">=</span> -<span class="number">1</span>) <span class="comment">% 如果文件无法打开则输出报错信息</span></span><br><span class="line">    disp(<span class="string">&quot;无法打开文件！&quot;</span>);</span><br><span class="line"><span class="built_in">else</span></span><br><span class="line">    disp(<span class="string">&#x27;成功打开文件！&#x27;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取文字行</span></span><br><span class="line"></span><br><span class="line">rowCnt <span class="built_in">=</span> fscanf(inFile,<span class="string">&#x27;%d %d\n&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取分割行</span></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取文字行</span></span><br><span class="line"></span><br><span class="line">factor <span class="built_in">=</span> rand(rowCnt(<span class="number">1</span>,<span class="number">1</span>),rowCnt(<span class="number">1</span>,<span class="number">1</span>));  <span class="comment">% 定义准则层</span></span><br><span class="line"></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span>:rowCnt(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    for j <span class="built_in">=</span> <span class="number">1</span>:rowCnt(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        factor(i,j) <span class="built_in">=</span> fscanf(inFile ,<span class="string">&#x27;%f&#x27;</span>, [<span class="number">1</span>,<span class="number">1</span>]); <span class="comment">% 读取准则层矩阵</span></span><br><span class="line">        <span class="built_in">if</span> (j <span class="built_in">=</span><span class="built_in">=</span> rowCnt(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">            fscanf(inFile,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取分割行</span></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取文字行</span></span><br><span class="line"></span><br><span class="line">RI <span class="built_in">=</span> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.58</span>,<span class="number">0.9</span>,<span class="number">1.12</span>,<span class="number">1.24</span>,<span class="number">1.32</span>,<span class="number">1.41</span>,<span class="number">1.45</span>,<span class="number">1.49</span>,<span class="number">1.52</span>,<span class="number">1.54</span>,<span class="number">1.56</span>,<span class="number">1.58</span>,<span class="number">1.59</span>]; <span class="comment">% 定义随机平均一致性指标</span></span><br><span class="line"></span><br><span class="line">[eigenvectors , eigenvalues] <span class="built_in">=</span> eig(factor);  <span class="comment">% 求出判断矩阵的所有特征值构成对角阵eigenvalues，以及所有特征向量构成矩阵eigenvectors</span></span><br><span class="line">max_eigenvalue <span class="built_in">=</span> max(diag(eigenvalues)); <span class="comment">% 求出最大的特征向量</span></span><br><span class="line">whichColumn <span class="built_in">=</span> find(diag(eigenvalues) <span class="built_in">=</span><span class="built_in">=</span> max_eigenvalue); <span class="comment">% 找出最大的特征值对应的特征向量在哪一列</span></span><br><span class="line">weightVector <span class="built_in">=</span> eigenvectors(:,whichColumn)/sum(eigenvectors(:,whichColumn)); <span class="comment">% 将找到的特征向量进行归一化处理</span></span><br><span class="line">disp(<span class="string">&quot;准则矩阵的权重向量是&quot;</span>);</span><br><span class="line">disp(weightVector<span class="string">&#x27;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CR0 = (max_eigenvalue - rowCnt(1,1))/(rowCnt(1,1) - 1)/RI(rowCnt(1,1));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if CR0 &lt; 0.1</span></span><br><span class="line"><span class="string">    disp([&#x27;</span>准则层判断矩阵的 CR 值为<span class="string">&#x27;, CR0, &#x27;</span>,一致性达到标准<span class="string">&#x27; newline]);</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    disp([&#x27;</span>准则层判断矩阵的 CR 值为<span class="string">&#x27;, CR0, &#x27;</span>,一致性未达标准<span class="string">&#x27; newline]);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">weightVector_plan = zeros(rowCnt(1,2),rowCnt(1,1));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i = 1:rowCnt(1,1)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    plan = zeros(rowCnt(1,2),rowCnt(1,2));    % 定义方案层矩阵</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for j = 1:rowCnt(1,2)</span></span><br><span class="line"><span class="string">        for k = 1:rowCnt(1,2)</span></span><br><span class="line"><span class="string">            plan(j,k) = fscanf(inFile ,&#x27;</span><span class="comment">%f&#x27;,[1,1]);  % 逐行输入得到各各要素下的方案层矩阵</span></span><br><span class="line">            <span class="built_in">if</span> (k <span class="built_in">=</span><span class="built_in">=</span> rowCnt(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">                fscanf(inFile,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    [eigenvectors_plan , eigenvalues_plan] <span class="built_in">=</span> eig(plan);  <span class="comment">% 求出判断矩阵的所有特征值构成对角阵eigenvalues，以及所有特征向量构成矩阵eigenvectors</span></span><br><span class="line">    max_eigenvalue_plan <span class="built_in">=</span> max(diag(eigenvalues_plan)); <span class="comment">% 求出最大的特征向量</span></span><br><span class="line">    whichColumn2 <span class="built_in">=</span> find(diag(eigenvalues_plan) <span class="built_in">=</span><span class="built_in">=</span> max_eigenvalue_plan); <span class="comment">% 找出最大的特征值对应的特征向量在哪一列</span></span><br><span class="line">    weightVector_plan(:,i) <span class="built_in">=</span> eigenvectors_plan(:,whichColumn2)/sum(eigenvectors_plan(:,whichColumn2)); <span class="comment">% 将找到的特征向量进行归一化处理</span></span><br><span class="line">    disp([<span class="string">&#x27;因素&#x27;</span>, num2str(i) ,<span class="string">&#x27;对应的各方案判断矩阵的权重向量是&#x27;</span>]);</span><br><span class="line">    disp(weightVector_plan(:,i)<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    CR1 = (max_eigenvalue_plan - rowCnt(1,2))/(rowCnt(1,2) - 1)/RI(rowCnt(1,2));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if CR1 &lt; 0.1</span></span><br><span class="line"><span class="string">        disp([&#x27;</span>因素<span class="string">&#x27;, num2str(i), &#x27;</span>各方案判断矩阵的 CR 值为<span class="string">&#x27;, num2str(CR1), &#x27;</span>,一致性达到标准<span class="string">&#x27; newline]);</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        disp([&#x27;</span>因素<span class="string">&#x27;, num2str(i), &#x27;</span>各方案判断矩阵的 CR 值为<span class="string">&#x27;, num2str(CR1), &#x27;</span>,一致性未达标准<span class="string">&#x27; newline]);</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">scores = zeros(rowCnt(1,2));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i= 1:rowCnt(1,2)</span></span><br><span class="line"><span class="string">    scores(i) = sum(weightVector_plan(i,:)&#x27;</span>.*weightVector);</span><br><span class="line">    disp([<span class="string">&#x27;方案&#x27;</span>, num2str(i) ,<span class="string">&#x27;的得分为&#x27;</span> , num2str(scores(i))]);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fclose(inFile);</span><br></pre></td></tr></table></figure><blockquote><p>提示：输入示例和算法代码可以参见我的 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm/AHP%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95">GitHub 仓库</a>（点击访问）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
